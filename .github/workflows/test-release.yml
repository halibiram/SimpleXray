name: "Test Release"

on:
  workflow_dispatch:
    inputs:
      workflow_run_id:
        description: "Workflow run ID to use (e.g., 19190879290). Leave empty to auto-detect"
        required: false
        type: string
      release_tag:
        description: "Release tag to use (e.g., v1.10.184). Leave empty to use latest successful release"
        required: false
        type: string
      test_version_suffix:
        description: "Test version suffix (e.g., -test1, -beta1)"
        required: false
        type: string
        default: "-test"

permissions:
  contents: write
  actions: read

jobs:
  create-test-release:
    name: Create Test Release from Latest APK
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: Initialize Valid Submodules
        run: |
          # Initialize required submodules
          # Use --recursive to initialize nested submodules
          git submodule sync || true

          # Initialize hev-socks5-tunnel with nested submodules (yaml, lwip, hev-task-system)
          git submodule update --init --recursive app/src/main/jni/hev-socks5-tunnel || true

          # Initialize QUICHE submodule with nested submodules (BoringSSL)
          # QUICHE headers are needed even if libraries are pre-built
          echo "ðŸ“¦ Initializing QUICHE submodule..."
          QUICHE_DIR="app/src/main/jni/quiche-client/third_party/quiche"

          # Ensure parent directory exists
          mkdir -p "$(dirname "$QUICHE_DIR")"

          # Try submodule update first
          if git submodule update --init --recursive "$QUICHE_DIR" 2>&1; then
            echo "âœ… QUICHE submodule updated via git submodule"
          else
            echo "âš ï¸  QUICHE submodule update failed, trying manual initialization..."
            # Remove if exists but incomplete
            if [ -d "$QUICHE_DIR" ] && [ ! -f "$QUICHE_DIR/.git" ]; then
              echo "Removing incomplete QUICHE directory..."
              rm -rf "$QUICHE_DIR"
            fi
            # Try manual clone if submodule update fails
            if [ ! -d "$QUICHE_DIR" ]; then
              echo "Cloning QUICHE repository manually..."
              git clone --depth=1 --recursive https://github.com/cloudflare/quiche.git "$QUICHE_DIR" || {
                echo "âŒ Failed to initialize QUICHE submodule"
                echo "This is non-fatal - build will continue without QUICHE support"
                # Don't exit - build can continue without QUICHE
              }
            fi
          fi

          # Verify QUICHE submodule structure
          if [ -d "$QUICHE_DIR/quiche" ] && [ -f "$QUICHE_DIR/quiche/Cargo.toml" ]; then
            echo "âœ… QUICHE submodule initialized correctly"
            echo "   Path: $QUICHE_DIR"
            echo "   Structure verified: quiche/Cargo.toml exists"
          elif [ -d "$QUICHE_DIR" ]; then
            echo "âš ï¸  QUICHE submodule directory exists but structure incomplete"
            echo "   Contents:"
            ls -la "$QUICHE_DIR" | head -10 || true
            echo "   Build will continue but QUICHE support may be disabled"
          else
            echo "âš ï¸  QUICHE submodule not found - build will continue without QUICHE"
          fi

          echo "âœ… Submodules initialized"

      - name: Setup GitHub CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y

      - name: Authenticate GitHub CLI
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token

      - name: Find Successful Workflow Run with Artifacts
        id: find_workflow
        run: |
          INPUT_RUN_ID="${{ inputs.workflow_run_id }}"
          
          if [ -n "$INPUT_RUN_ID" ]; then
            echo "âœ… Using specified workflow run ID: $INPUT_RUN_ID"
            
            # Verify the run exists and is successful
            RUN_INFO=$(gh run view "$INPUT_RUN_ID" --json conclusion,displayTitle,createdAt 2>/dev/null || echo "")
            if [ -z "$RUN_INFO" ]; then
              echo "âŒ Workflow run $INPUT_RUN_ID not found"
              exit 1
            fi
            
            RUN_CONCLUSION=$(echo "$RUN_INFO" | jq -r '.conclusion' 2>/dev/null || echo "")
            if [ "$RUN_CONCLUSION" != "success" ]; then
              echo "âš ï¸  Workflow run $INPUT_RUN_ID is not successful (conclusion: $RUN_CONCLUSION)"
              echo "   Continuing anyway..."
            fi
            
            # Check if this run has artifacts using API
            ARTIFACTS=$(gh api repos/${{ github.repository }}/actions/runs/$INPUT_RUN_ID/artifacts --jq '.artifacts[] | .name' 2>/dev/null || echo "")
            if [ -n "$ARTIFACTS" ] && [ "$ARTIFACTS" != "" ]; then
              echo "âœ… Found artifacts in run $INPUT_RUN_ID:"
              echo "$ARTIFACTS" | while read -r artifact; do
                if [ -n "$artifact" ]; then
                  echo "   - $artifact"
                fi
              done
              FOUND_RUN_ID="$INPUT_RUN_ID"
              echo "run_id=$FOUND_RUN_ID" >> $GITHUB_OUTPUT
              echo "use_release=false" >> $GITHUB_OUTPUT
              echo "âœ… Will use artifacts from run $INPUT_RUN_ID"
              exit 0
            else
              echo "âš ï¸  No artifacts found in run $INPUT_RUN_ID, will check releases..."
            fi
          fi
          
          echo "ðŸ” Finding successful Auto Release workflow run with artifacts..."
          
          # Get workflow file name
          WORKFLOW_FILE=".github/workflows/auto-release.yml"
          
          # Get successful workflow runs for auto-release workflow
          # Try different ways to find the workflow
          WORKFLOW_RUNS=$(gh run list --workflow="$WORKFLOW_FILE" --limit 20 --json databaseId,conclusion,createdAt,displayTitle --jq '.[] | select(.conclusion == "success") | "\(.databaseId)|\(.createdAt)|\(.displayTitle)"' 2>/dev/null || echo "")
          
          # If not found, try to find by workflow name pattern
          if [ -z "$WORKFLOW_RUNS" ]; then
            echo "âš ï¸  Not found by file name, trying to find by workflow runs..."
            # List all workflows to find the right one
            ALL_WORKFLOWS=$(gh workflow list --limit 50 --json name,id,path --jq '.[] | "\(.name)|\(.id)|\(.path)"' || echo "")
            echo "ðŸ“‹ Available workflows:"
            echo "$ALL_WORKFLOWS" | head -10
            
            # Try to find workflow with "release" in name
            RELEASE_WORKFLOW_ID=$(echo "$ALL_WORKFLOWS" | grep -i "release\|auto" | head -1 | cut -d'|' -f2 || echo "")
            if [ -n "$RELEASE_WORKFLOW_ID" ]; then
              echo "âœ… Found workflow ID: $RELEASE_WORKFLOW_ID"
              WORKFLOW_RUNS=$(gh run list --workflow="$RELEASE_WORKFLOW_ID" --limit 20 --json databaseId,conclusion,createdAt,displayTitle --jq '.[] | select(.conclusion == "success") | "\(.databaseId)|\(.createdAt)|\(.displayTitle)"' 2>/dev/null || echo "")
            fi
          fi
          
          # If still not found, try to get all successful runs and filter
          if [ -z "$WORKFLOW_RUNS" ]; then
            echo "âš ï¸  Trying to find any successful runs..."
            WORKFLOW_RUNS=$(gh run list --limit 50 --json databaseId,conclusion,createdAt,displayTitle,workflowName --jq '.[] | select(.conclusion == "success" and (.workflowName | test("release|auto"; "i"))) | "\(.databaseId)|\(.createdAt)|\(.displayTitle)"' 2>/dev/null || echo "")
          fi
          
          if [ -z "$WORKFLOW_RUNS" ]; then
            echo "âŒ No successful Auto Release workflow runs found"
            exit 1
          fi
          
          echo "ðŸ“‹ Found successful workflow runs:"
          echo "$WORKFLOW_RUNS" | head -5
          echo ""
          
          # Try to find a run with artifacts first
          FOUND_RUN_ID=""
          for run_info in $WORKFLOW_RUNS; do
            RUN_ID=$(echo "$run_info" | cut -d'|' -f1)
            CREATED_AT=$(echo "$run_info" | cut -d'|' -f2)
            TITLE=$(echo "$run_info" | cut -d'|' -f3-)
            
            echo "  Checking run $RUN_ID ($CREATED_AT)..."
            
            # Check if this run has artifacts using API
            ARTIFACTS=$(gh api repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts --jq '.artifacts[] | .name' 2>/dev/null || echo "")
            
            if [ -n "$ARTIFACTS" ] && [ "$ARTIFACTS" != "" ]; then
              FOUND_RUN_ID="$RUN_ID"
              echo "âœ… Found successful run with artifacts: $RUN_ID"
              echo "   Artifacts:"
              echo "$ARTIFACTS" | while read -r artifact; do
                if [ -n "$artifact" ]; then
                  echo "     - $artifact"
                fi
              done
              break
            else
              echo "   No artifacts found"
            fi
          done
          
          # If no artifacts found, try to find release with APK from these runs
          if [ -z "$FOUND_RUN_ID" ]; then
            echo "âš ï¸  No artifacts found in workflow runs, checking releases..."
            
            # Get all releases and find one with APK
            ALL_RELEASES=$(gh release list --limit 20 --json tagName,createdAt --jq '.[] | "\(.tagName)|\(.createdAt)"' || echo "")
            
            if [ -z "$ALL_RELEASES" ]; then
              echo "âŒ No releases found"
              exit 1
            fi
            
            # Function to check if release has APK
            check_release_has_apk() {
              local tag=$1
              local release_info=$(gh release view "$tag" --json assets 2>/dev/null)
              local exit_code=$?
              
              if [ $exit_code -ne 0 ] || [ -z "$release_info" ]; then
                echo "âš ï¸  Failed to get release info for $tag" >&2
                return 1
              fi
              
              # Check if release has any assets
              local asset_count=$(echo "$release_info" | jq -r '.assets | length' 2>/dev/null || echo "0")
              if [ "$asset_count" = "0" ] || [ -z "$asset_count" ]; then
                return 1
              fi
              
              # Find APK asset
              local apk_asset=$(echo "$release_info" | jq -r '.assets[] | select(.name | endswith(".apk")) | .name' 2>/dev/null | head -1)
              
              if [ -n "$apk_asset" ] && [ "$apk_asset" != "null" ] && [ "$apk_asset" != "" ]; then
                echo "$apk_asset"
                return 0
              fi
              
              return 1
            }
            
            # Check each release for APK
            FOUND_RELEASE_TAG=""
            FOUND_APK_NAME=""
            for release_info in $ALL_RELEASES; do
              RELEASE_TAG=$(echo "$release_info" | cut -d'|' -f1)
              CREATED_AT=$(echo "$release_info" | cut -d'|' -f2)
              
              echo "  Checking release $RELEASE_TAG ($CREATED_AT)..."
              
              # Use set +e to continue on error
              set +e
              APK_ASSET=$(check_release_has_apk "$RELEASE_TAG" 2>&1)
              local check_exit=$?
              set -e
              
              if [ $check_exit -eq 0 ] && [ -n "$APK_ASSET" ]; then
                FOUND_RELEASE_TAG="$RELEASE_TAG"
                FOUND_APK_NAME="$APK_ASSET"
                echo "âœ… Found release with APK: $FOUND_RELEASE_TAG"
                echo "   APK: $FOUND_APK_NAME"
                break
              else
                if [ -n "$APK_ASSET" ] && echo "$APK_ASSET" | grep -q "âš ï¸"; then
                  echo "$APK_ASSET"
                else
                  echo "   No APK found in this release"
                fi
              fi
            done
            
            if [ -z "$FOUND_RELEASE_TAG" ]; then
              echo "âŒ No release with APK found"
              exit 1
            fi
            
            echo "release_tag=$FOUND_RELEASE_TAG" >> $GITHUB_OUTPUT
            echo "apk_name=$FOUND_APK_NAME" >> $GITHUB_OUTPUT
            echo "use_release=true" >> $GITHUB_OUTPUT
          else
            echo "run_id=$FOUND_RUN_ID" >> $GITHUB_OUTPUT
            echo "use_release=false" >> $GITHUB_OUTPUT
          fi

      - name: Download Artifacts from Workflow Run
        id: download_artifacts
        run: |
          RUN_ID="${{ steps.find_workflow.outputs.run_id }}"
          
          if [ -z "$RUN_ID" ]; then
            echo "âŒ No workflow run ID found"
            exit 1
          fi
          
          echo "ðŸ“¥ Downloading artifacts from workflow run $RUN_ID..."
          
          mkdir -p artifacts-temp
          
          # Download all artifacts from the workflow run
          gh run download "$RUN_ID" --dir artifacts-temp/ || {
            echo "âŒ Failed to download artifacts from workflow run"
            exit 1
          }
          
          echo "ðŸ“¦ Downloaded artifacts:"
          find artifacts-temp -type f -exec ls -lh {} \; 2>/dev/null | head -20 || echo "  No files found"
          
          # List artifact directories
          echo "ðŸ“ Artifact directories:"
          ls -la artifacts-temp/ || echo "  No directories found"

      - name: Set up Java 21
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"
          cache: "gradle"

      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      - name: Setup Keystore and Properties
        env:
          KEYSTORE_PASSWORD: ${{ secrets.SIGNING_STORE_PASSWORD }}
          KEY_PASSWORD: ${{ secrets.SIGNING_KEY_PASSWORD }}
        run: |
          echo "${{ secrets.SIGNING_KEYSTORE }}" > keystore.b64
          base64 -d keystore.b64 > ./store.jks
          rm keystore.b64
          echo "storeFile=store.jks" > ./store.properties
          echo "storePassword=${{ secrets.SIGNING_STORE_PASSWORD }}" >> ./store.properties
          echo "keyAlias=${{ secrets.SIGNING_KEY_ALIAS }}" >> ./store.properties
          echo "keyPassword=${{ secrets.SIGNING_KEY_PASSWORD }}" >> ./store.properties

      - name: Copy Native Libraries from Artifacts
        run: |
          echo "ðŸ“¦ Copying native libraries from artifacts..."
          
          # Ensure jniLibs directory structure exists
          mkdir -p app/src/main/jniLibs
          
          # Copy Xray libraries
          if [ -d "artifacts-temp/xray-arm64-v8a" ]; then
            mkdir -p app/src/main/jniLibs/arm64-v8a
            cp artifacts-temp/xray-arm64-v8a/libxray.so app/src/main/jniLibs/arm64-v8a/ 2>/dev/null || echo "âš ï¸  libxray.so not found in xray-arm64-v8a"
            echo "âœ… Copied Xray library for arm64-v8a"
          fi
          
          if [ -d "artifacts-temp/xray-x86_64" ]; then
            mkdir -p app/src/main/jniLibs/x86_64
            cp artifacts-temp/xray-x86_64/libxray.so app/src/main/jniLibs/x86_64/ 2>/dev/null || echo "âš ï¸  libxray.so not found in xray-x86_64"
            echo "âœ… Copied Xray library for x86_64"
          fi
          
          # Copy Hysteria2 libraries
          if [ -d "artifacts-temp/hysteria2-arm64-v8a" ]; then
            mkdir -p app/src/main/jniLibs/arm64-v8a
            cp artifacts-temp/hysteria2-arm64-v8a/libhysteria2.so app/src/main/jniLibs/arm64-v8a/ 2>/dev/null || echo "âš ï¸  libhysteria2.so not found in hysteria2-arm64-v8a"
            echo "âœ… Copied Hysteria2 library for arm64-v8a"
          fi
          
          if [ -d "artifacts-temp/hysteria2-x86_64" ]; then
            mkdir -p app/src/main/jniLibs/x86_64
            cp artifacts-temp/hysteria2-x86_64/libhysteria2.so app/src/main/jniLibs/x86_64/ 2>/dev/null || echo "âš ï¸  libhysteria2.so not found in hysteria2-x86_64"
            echo "âœ… Copied Hysteria2 library for x86_64"
          fi
          
          # Copy QUICHE libraries
          if [ -d "artifacts-temp/quiche-arm64-v8a" ]; then
            mkdir -p app/src/main/jni/quiche-client/libs/arm64-v8a
            cp artifacts-temp/quiche-arm64-v8a/libquiche.a app/src/main/jni/quiche-client/libs/arm64-v8a/ 2>/dev/null || echo "âš ï¸  libquiche.a not found"
            cp artifacts-temp/quiche-arm64-v8a/libquiche.so app/src/main/jni/quiche-client/libs/arm64-v8a/ 2>/dev/null || echo "âš ï¸  libquiche.so not found"
            echo "âœ… Copied QUICHE libraries for arm64-v8a"
          fi
          
          if [ -d "artifacts-temp/quiche-x86_64" ]; then
            mkdir -p app/src/main/jni/quiche-client/libs/x86_64
            cp artifacts-temp/quiche-x86_64/libquiche.a app/src/main/jni/quiche-client/libs/x86_64/ 2>/dev/null || echo "âš ï¸  libquiche.a not found"
            cp artifacts-temp/quiche-x86_64/libquiche.so app/src/main/jni/quiche-client/libs/x86_64/ 2>/dev/null || echo "âš ï¸  libquiche.so not found"
            echo "âœ… Copied QUICHE libraries for x86_64"
          fi
          
          # Verify libraries
          echo "ðŸ“‹ Verifying native libraries:"
          find app/src/main/jniLibs -name "*.so" -type f 2>/dev/null | head -10 || echo "âš ï¸  No .so files found"
          find app/src/main/jni/quiche-client/libs -name "libquiche.*" -type f 2>/dev/null | head -10 || echo "âš ï¸  No QUICHE libraries found"

      - name: Build BoringSSL for QUICHE
        run: |
          echo "ðŸ”¨ Building BoringSSL for QUICHE..."
          
          # Get NDK path from Android SDK
          NDK_HOME="$ANDROID_HOME/ndk/$(ls -1 $ANDROID_HOME/ndk | head -1)"
          if [ ! -d "$NDK_HOME" ]; then
            echo "âŒ NDK not found at $NDK_HOME"
            exit 1
          fi
          echo "Using NDK: $NDK_HOME"
          
          # Install build tools
          sudo apt-get update
          sudo apt-get install -y ninja-build cmake
          
          # BoringSSL path in QUICHE submodule
          BORINGSSL_DIR="app/src/main/jni/quiche-client/third_party/quiche/quiche/deps/boringssl"
          
          # Check if QUICHE library exists - if not, we don't need BoringSSL
          QUICHE_LIB="app/src/main/jni/quiche-client/libs/arm64-v8a/libquiche.a"
          if [ ! -f "$QUICHE_LIB" ]; then
            echo "âš ï¸  QUICHE library not found at $QUICHE_LIB"
            echo "   QUICHE build will be skipped, BoringSSL not needed"
            exit 0
          fi
          
          if [ ! -d "$BORINGSSL_DIR" ]; then
            echo "âŒ BoringSSL directory not found at $BORINGSSL_DIR"
            echo "   QUICHE library exists but BoringSSL is missing - build will fail"
            exit 1
          fi
          
          if [ ! -f "$BORINGSSL_DIR/CMakeLists.txt" ]; then
            echo "âŒ BoringSSL CMakeLists.txt not found at $BORINGSSL_DIR/CMakeLists.txt"
            echo "   QUICHE library exists but BoringSSL is incomplete - build will fail"
            exit 1
          fi
          
          echo "âœ… BoringSSL source found, building libraries..."
          cd "$BORINGSSL_DIR"
          
          # Set up toolchain
          TOOLCHAIN_DIR="$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64"
          export PATH=$TOOLCHAIN_DIR/bin:$PATH
          export CC=aarch64-linux-android24-clang
          export CXX=aarch64-linux-android24-clang++
          export AR=$TOOLCHAIN_DIR/bin/llvm-ar
          export RANLIB=$TOOLCHAIN_DIR/bin/llvm-ranlib
          export ANDROID_NDK_HOME=$NDK_HOME
          export ANDROID_NDK_ROOT=$NDK_HOME
          
          # Create build directory (Android.mk expects it at build/)
          # Clean if exists to avoid stale builds
          BUILD_DIR="build"
          if [ -d "$BUILD_DIR" ]; then
            echo "ðŸ§¹ Cleaning existing build directory..."
            rm -rf "$BUILD_DIR"
          fi
          mkdir -p "$BUILD_DIR"
          cd "$BUILD_DIR"
          
          echo "ðŸ“¦ Configuring BoringSSL with CMake..."
          # Configure BoringSSL with CMake
          if ! cmake .. \
            -DCMAKE_SYSTEM_NAME=Android \
            -DCMAKE_SYSTEM_VERSION=24 \
            -DCMAKE_ANDROID_ARCH_ABI=arm64-v8a \
            -DCMAKE_ANDROID_NDK=$NDK_HOME \
            -DCMAKE_TOOLCHAIN_FILE=$NDK_HOME/build/cmake/android.toolchain.cmake \
            -DCMAKE_BUILD_TYPE=Release \
            -DOPENSSL_SMALL=1 \
            -DOPENSSL_NO_DEPRECATED=1 \
            -DOPENSSL_NO_ASM=0 \
            -DBUILD_SHARED_LIBS=OFF \
            -GNinja; then
            echo "âŒ CMake configuration failed"
            exit 1
          fi
          
          echo "ðŸ”¨ Building BoringSSL with Ninja..."
          # Build
          if ! ninja -j$(nproc); then
            echo "âŒ BoringSSL build failed"
            echo "ðŸ“‹ Build directory contents:"
            ls -la || true
            exit 1
          fi
          
          # Verify libraries were created
          if [ ! -f "crypto/libcrypto.a" ] || [ ! -f "ssl/libssl.a" ]; then
            echo "âŒ BoringSSL libraries not found after build"
            echo "ðŸ“‹ Build directory contents:"
            find . -name "*.a" -type f || true
            ls -la crypto/ ssl/ || true
            exit 1
          fi
          
          echo "âœ… BoringSSL build complete for arm64-v8a"
          ls -lh crypto/libcrypto.a ssl/libssl.a
          
          # Verify the expected paths exist
          EXPECTED_CRYPTO="$(pwd)/crypto/libcrypto.a"
          EXPECTED_SSL="$(pwd)/ssl/libssl.a"
          echo "ðŸ“‹ Libraries at expected paths:"
          echo "   Crypto: $EXPECTED_CRYPTO"
          echo "   SSL: $EXPECTED_SSL"
          
          cd ../../../../../../..
          
          # Final verification from project root
          echo "ðŸ” Final verification of BoringSSL libraries..."
          BORINGSSL_CRYPTO="app/src/main/jni/quiche-client/third_party/quiche/quiche/deps/boringssl/build/crypto/libcrypto.a"
          BORINGSSL_SSL="app/src/main/jni/quiche-client/third_party/quiche/quiche/deps/boringssl/build/ssl/libssl.a"
          
          if [ -f "$BORINGSSL_CRYPTO" ] && [ -f "$BORINGSSL_SSL" ]; then
            echo "âœ… BoringSSL libraries verified at expected paths:"
            ls -lh "$BORINGSSL_CRYPTO" "$BORINGSSL_SSL"
          else
            echo "âŒ BoringSSL libraries not found at expected paths!"
            echo "   Expected: $BORINGSSL_CRYPTO"
            echo "   Expected: $BORINGSSL_SSL"
            echo "ðŸ“‹ Checking if BoringSSL directory exists:"
            ls -la app/src/main/jni/quiche-client/third_party/quiche/quiche/deps/boringssl/ || true
            exit 1
          fi

      - name: Download Rules Files
        run: |
          if [ -f "version.properties" ]; then
            GEOIP_VERSION=$(grep 'GEOIP_VERSION' version.properties | cut -d '=' -f 2)
            GEOSITE_VERSION=$(grep 'GEOSITE_VERSION' version.properties | cut -d '=' -f 2)
          else
            # Use default versions if not found
            GEOIP_VERSION="202411080001"
            GEOSITE_VERSION="202411080001"
          fi
          
          if [ -z "$GEOIP_VERSION" ] || [ -z "$GEOSITE_VERSION" ]; then
            echo "âš ï¸  GEOIP_VERSION or GEOSITE_VERSION not set, using defaults"
            GEOIP_VERSION="202411080001"
            GEOSITE_VERSION="202411080001"
          fi
          
          mkdir -p app/src/main/assets
          wget https://github.com/lhear/v2ray-rules-dat/releases/download/$GEOIP_VERSION/geoip.dat -O ./app/src/main/assets/geoip.dat || echo "âš ï¸  Failed to download geoip.dat"
          wget https://github.com/lhear/v2ray-rules-dat/releases/download/$GEOSITE_VERSION/geosite.dat -O ./app/src/main/assets/geosite.dat || echo "âš ï¸  Failed to download geosite.dat"

      - name: Make gradlew executable
        run: chmod +x ./gradlew

      - name: Verify QUICHE Submodule Before Build
        run: |
          echo "ðŸ” Verifying QUICHE submodule before build..."
          QUICHE_DIR="app/src/main/jni/quiche-client/third_party/quiche"
          if [ -d "$QUICHE_DIR/quiche" ]; then
            echo "âœ… QUICHE submodule directory exists"
            if [ -f "$QUICHE_DIR/quiche/Cargo.toml" ]; then
              echo "âœ… QUICHE Cargo.toml found"
            else
              echo "âš ï¸  QUICHE Cargo.toml not found"
            fi
            if [ -d "$QUICHE_DIR/quiche/deps/boringssl" ]; then
              echo "âœ… QUICHE BoringSSL dependency found"
              
              # Check if BoringSSL libraries were built
              BORINGSSL_BUILD_DIR="$QUICHE_DIR/quiche/deps/boringssl/build"
              if [ -f "$BORINGSSL_BUILD_DIR/crypto/libcrypto.a" ] && [ -f "$BORINGSSL_BUILD_DIR/ssl/libssl.a" ]; then
                echo "âœ… BoringSSL libraries found:"
                ls -lh "$BORINGSSL_BUILD_DIR/crypto/libcrypto.a" "$BORINGSSL_BUILD_DIR/ssl/libssl.a"
              else
                echo "âš ï¸  BoringSSL libraries not found (QUICHE build may fail)"
                echo "   Expected: $BORINGSSL_BUILD_DIR/crypto/libcrypto.a"
                echo "   Expected: $BORINGSSL_BUILD_DIR/ssl/libssl.a"
              fi
            else
              echo "âš ï¸  QUICHE BoringSSL dependency not found"
            fi
          else
            echo "âš ï¸  QUICHE submodule directory not found (build may skip QUICHE)"
          fi

      - name: Build Release APK
        env:
          KEYSTORE_PASSWORD: ${{ secrets.SIGNING_STORE_PASSWORD }}
          KEY_PASSWORD: ${{ secrets.SIGNING_KEY_PASSWORD }}
        run: |
          echo "ðŸ”¨ Building release APK with downloaded artifacts..."
          # Capture Gradle output to file for better error reporting
          set +e  # Don't exit on error immediately
          ./gradlew assembleRelease --stacktrace --warning-mode all 2>&1 | tee gradle-build.log
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          set -e  # Re-enable exit on error

          if [ "$BUILD_EXIT_CODE" -ne 0 ]; then
            echo "âŒ Build failed with exit code: $BUILD_EXIT_CODE"
            echo ""
            echo "=== First 50 lines of Gradle output (for context) ==="
            head -50 gradle-build.log || echo "Could not read build log"
            echo ""
            echo "=== Last 150 lines of Gradle output (most recent errors) ==="
            tail -150 gradle-build.log || echo "Could not read build log"
            echo ""
            echo "=== Searching for FAILURE messages ==="
            grep -i "FAILURE\|BUILD FAILED" gradle-build.log | tail -10 || echo "No FAILURE messages found"
            echo ""
            echo "=== Searching for error patterns ==="
            grep -i "error\|failed\|exception" gradle-build.log | grep -v "at org.gradle" | tail -30 || echo "No error patterns found"
            echo ""
            echo "=== Checking for build logs ==="
            find app/build -name "*.log" -type f 2>/dev/null | head -5
            echo ""
            echo "=== Checking for error reports ==="
            find app/build -name "*error*" -type f 2>/dev/null | head -5
            echo ""
            echo "=== Build output directory structure ==="
            ls -la app/build/outputs/ 2>/dev/null || echo "  app/build/outputs/ does not exist"
            echo ""
            echo "=== Gradle build log location ==="
            echo "Full log available at: gradle-build.log"
            echo "âŒ Build failed - cannot proceed without APK"
            exit 1
          fi
          
          echo "âœ… Build completed"
          
          # Verify APK was generated
          if [ -f "app/build/outputs/apk/release/simplexray-arm64-v8a.apk" ]; then
            APK_SIZE=$(stat -c%s "app/build/outputs/apk/release/simplexray-arm64-v8a.apk" 2>/dev/null || echo "0")
            APK_SIZE_MB=$((APK_SIZE / 1024 / 1024))
            echo "âœ… APK generated: simplexray-arm64-v8a.apk (${APK_SIZE_MB}MB)"
            echo "apk_name=simplexray-arm64-v8a.apk" >> $GITHUB_OUTPUT
            echo "apk_path=app/build/outputs/apk/release/simplexray-arm64-v8a.apk" >> $GITHUB_OUTPUT
          else
            echo "âŒ APK not found at expected location"
            find app/build -name "*.apk" -type f 2>/dev/null | head -10 || echo "No APKs found"
            exit 1
          fi

      - name: Copy APK to Release Artifacts
        run: |
          mkdir -p release-artifacts
          cp app/build/outputs/apk/release/simplexray-arm64-v8a.apk release-artifacts/
          echo "âœ… APK copied to release-artifacts/"
          ls -lh release-artifacts/

      - name: Read Version from Properties
        id: version
        run: |
          if [ -f "version.properties" ]; then
            VERSION_NAME=$(grep 'APP_VERSION_NAME' version.properties | cut -d '=' -f 2)
            VERSION_CODE=$(grep 'APP_VERSION_CODE' version.properties | cut -d '=' -f 2)
          else
            # Use current date as version if properties not found
            VERSION_NAME=$(date +"%Y.%m.%d")
            VERSION_CODE="1"
          fi
          
          TEST_SUFFIX="${{ inputs.test_version_suffix }}"
          TEST_VERSION_NAME="${VERSION_NAME}${TEST_SUFFIX}"
          
          echo "version_name=$VERSION_NAME" >> $GITHUB_OUTPUT
          echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT
          echo "test_version_name=$TEST_VERSION_NAME" >> $GITHUB_OUTPUT
          echo "tag=v${TEST_VERSION_NAME}" >> $GITHUB_OUTPUT
          
          echo "ðŸ“‹ Version Information:"
          echo "  Original Version: $VERSION_NAME"
          echo "  Test Version: $TEST_VERSION_NAME"
          echo "  Test Tag: v${TEST_VERSION_NAME}"

      - name: Check if Test Tag Exists
        id: check_tag
        run: |
          TEST_TAG="v${{ steps.version.outputs.test_version_name }}"
          if git ls-remote --tags origin | grep -q "refs/tags/${TEST_TAG}$"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âš ï¸  Tag $TEST_TAG already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âœ… Tag $TEST_TAG does not exist, proceeding"
          fi

      - name: Create Test Release
        if: steps.check_tag.outputs.exists == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TEST_TAG="v${{ steps.version.outputs.test_version_name }}"
          RUN_ID="${{ steps.find_workflow.outputs.run_id }}"
          VERSION_NAME="${{ steps.version.outputs.test_version_name }}"
          BUILD_CODE="${{ steps.version.outputs.version_code }}"
          COMMIT="${{ github.sha }}"
          APK_PATH="release-artifacts/simplexray-arm64-v8a.apk"
          APK_NAME="simplexray-arm64-v8a.apk"
          
          SOURCE_INFO="Workflow Run $RUN_ID (APK built from artifacts)"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Create and push tag
          git tag -a "$TEST_TAG" -m "Test Release $TEST_TAG (from $SOURCE_INFO)"
          git push origin "$TEST_TAG"
          
          # Create release notes
          cat > release_notes.md << EOF
          ðŸ§ª Test Release for version ${VERSION_NAME}
          
          **Source:** ${SOURCE_INFO}
          **Test Version:** ${TEST_VERSION_NAME}
          **Build Code:** ${BUILD_CODE}
          **Commit:** ${COMMIT}
          
          **Note:** This is a test release. APK was built using native libraries from ${SOURCE_INFO}.
          Native libraries (Xray, Hysteria2, QUICHE, BoringSSL) were downloaded from the workflow run and used to build the APK.
          
          **Download APK:**
          - \`${APK_NAME}\` - For most modern devices (ARM64) - BoringSSL optimized
          
          **Features:**
          - ðŸ”’ BoringSSL integration (replaces OpenSSL)
          - âš¡ Hardware-accelerated crypto (AES-GCM, ChaCha20-Poly1305)
          - ðŸš€ TLS 1.3 with Chrome mobile fingerprint mimic
          - ðŸ“¡ QUIC/HTTP3 support
          - ðŸŽ¯ Xray-core built with BoringSSL (3-40x faster crypto performance)
          - ðŸŒŠ Hysteria2 QUIC acceleration (standalone or chain mode)
          
          ---
          ðŸ¤– Auto-generated test release from ${SOURCE_INFO}
          EOF
          
          # Create release with APK
          if [ -n "$APK_PATH" ] && [ -f "$APK_PATH" ]; then
            echo "ðŸ“¦ Creating test release with APK..."
            gh release create "$TEST_TAG" \
              --title "SimpleXray Test Release $TEST_TAG" \
              --notes-file release_notes.md \
              --prerelease \
              "$APK_PATH"
            
            echo "âœ… Test release created: https://github.com/${{ github.repository }}/releases/tag/$TEST_TAG"
          else
            echo "âŒ APK file not found: $APK_PATH"
            echo "ðŸ“ Available files in release-artifacts/:"
            ls -lah release-artifacts/ || echo "Directory does not exist"
            exit 1
          fi

      - name: Send Test Release Notification to Telegram
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          BOT_TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}"
          CHAT_ID="${{ secrets.TELEGRAM_CHAT_ID }}"
          
          if [ -z "$BOT_TOKEN" ] || [ -z "$CHAT_ID" ]; then
            echo "âš ï¸  Telegram secrets not configured, skipping notification"
            exit 0
          fi
          
          TEST_TAG="v${{ steps.version.outputs.test_version_name }}"
          RUN_ID="${{ steps.find_workflow.outputs.run_id }}"
          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/$TEST_TAG"
          
          TEXT="ðŸ§ª *Test Release Created*\n\nðŸ“¦ *Version:* $TEST_TAG\nðŸ“‹ *Source:* Workflow Run $RUN_ID\nðŸ”¨ *Build:* ${{ steps.version.outputs.version_code }}\n\nâ„¹ï¸ *Note:* This is a test release. APK was built using native libraries from workflow run $RUN_ID.\n\nðŸ”— [Download Test Release]($RELEASE_URL)"
          
          curl -s -X POST \
            -H "Content-Type: application/json" \
            -d "{\"chat_id\": \"$CHAT_ID\", \"text\": \"$TEXT\", \"parse_mode\": \"Markdown\"}" \
            "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" || echo "âš ï¸  Failed to send Telegram notification"

