name: "Test Release"

on:
  workflow_dispatch:
    inputs:
      workflow_run_id:
        description: "Workflow run ID to use (e.g., 19190879290). Leave empty to auto-detect"
        required: false
        type: string
      release_tag:
        description: "Release tag to use (e.g., v1.10.184). Leave empty to use latest successful release"
        required: false
        type: string
      test_version_suffix:
        description: "Test version suffix (e.g., -test1, -beta1)"
        required: false
        type: string
        default: "-test"

permissions:
  contents: write
  actions: read

jobs:
  create-test-release:
    name: Create Test Release from Latest APK
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: Initialize QUICHE Submodule
        run: |
          echo "ðŸ“¦ Initializing QUICHE submodule..."
          QUICHE_DIR="app/src/main/jni/quiche-client/third_party/quiche"
          
          # Ensure parent directory exists
          mkdir -p "$(dirname "$QUICHE_DIR")"
          
          # Try submodule update first
          if git submodule update --init --recursive "$QUICHE_DIR" 2>&1; then
            echo "âœ… QUICHE submodule updated via git submodule"
          else
            echo "âš ï¸  QUICHE submodule update failed, trying manual initialization..."
            # Remove if exists but incomplete
            if [ -d "$QUICHE_DIR" ] && [ ! -f "$QUICHE_DIR/.git" ]; then
              echo "Removing incomplete QUICHE directory..."
              rm -rf "$QUICHE_DIR"
            fi
            # Try manual clone if submodule update fails
            if [ ! -d "$QUICHE_DIR" ]; then
              echo "Cloning QUICHE repository manually..."
              git clone --depth=1 --recursive https://github.com/cloudflare/quiche.git "$QUICHE_DIR" || {
                echo "âŒ Failed to initialize QUICHE submodule"
                echo "This is non-fatal - build will continue without QUICHE support"
                # Don't exit - build can continue without QUICHE
              }
            fi
          fi
          
          # Verify QUICHE submodule structure
          if [ -d "$QUICHE_DIR/quiche" ] && [ -f "$QUICHE_DIR/quiche/Cargo.toml" ]; then
            echo "âœ… QUICHE submodule initialized correctly"
          elif [ -d "$QUICHE_DIR" ]; then
            echo "âš ï¸  QUICHE submodule directory exists but structure incomplete"
            echo "   Build will continue but QUICHE support may be disabled"
          else
            echo "âš ï¸  QUICHE submodule not found - build will continue without QUICHE"
          fi

      - name: Setup GitHub CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y

      - name: Authenticate GitHub CLI
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token

      - name: Find Successful Workflow Run with Artifacts
        id: find_workflow
        run: |
          INPUT_RUN_ID="${{ inputs.workflow_run_id }}"
          
          if [ -n "$INPUT_RUN_ID" ]; then
            echo "âœ… Using specified workflow run ID: $INPUT_RUN_ID"
            
            # Verify the run exists and is successful
            RUN_INFO=$(gh run view "$INPUT_RUN_ID" --json conclusion,displayTitle,createdAt 2>/dev/null || echo "")
            if [ -z "$RUN_INFO" ]; then
              echo "âŒ Workflow run $INPUT_RUN_ID not found"
              exit 1
            fi
            
            RUN_CONCLUSION=$(echo "$RUN_INFO" | jq -r '.conclusion' 2>/dev/null || echo "")
            if [ "$RUN_CONCLUSION" != "success" ]; then
              echo "âš ï¸  Workflow run $INPUT_RUN_ID is not successful (conclusion: $RUN_CONCLUSION)"
              echo "   Continuing anyway..."
            fi
            
            # Check if this run has artifacts using API
            ARTIFACTS=$(gh api repos/${{ github.repository }}/actions/runs/$INPUT_RUN_ID/artifacts --jq '.artifacts[] | .name' 2>/dev/null || echo "")
            if [ -n "$ARTIFACTS" ] && [ "$ARTIFACTS" != "" ]; then
              echo "âœ… Found artifacts in run $INPUT_RUN_ID:"
              echo "$ARTIFACTS" | while read -r artifact; do
                if [ -n "$artifact" ]; then
                  echo "   - $artifact"
                fi
              done
              FOUND_RUN_ID="$INPUT_RUN_ID"
              echo "run_id=$FOUND_RUN_ID" >> $GITHUB_OUTPUT
              echo "use_release=false" >> $GITHUB_OUTPUT
              echo "âœ… Will use artifacts from run $INPUT_RUN_ID"
              exit 0
            else
              echo "âš ï¸  No artifacts found in run $INPUT_RUN_ID, will check releases..."
            fi
          fi
          
          echo "ðŸ” Finding successful Auto Release workflow run with artifacts..."
          
          # Get workflow file name
          WORKFLOW_FILE=".github/workflows/auto-release.yml"
          
          # Get successful workflow runs for auto-release workflow
          # Try different ways to find the workflow
          WORKFLOW_RUNS=$(gh run list --workflow="$WORKFLOW_FILE" --limit 20 --json databaseId,conclusion,createdAt,displayTitle --jq '.[] | select(.conclusion == "success") | "\(.databaseId)|\(.createdAt)|\(.displayTitle)"' 2>/dev/null || echo "")
          
          # If not found, try to find by workflow name pattern
          if [ -z "$WORKFLOW_RUNS" ]; then
            echo "âš ï¸  Not found by file name, trying to find by workflow runs..."
            # List all workflows to find the right one
            ALL_WORKFLOWS=$(gh workflow list --limit 50 --json name,id,path --jq '.[] | "\(.name)|\(.id)|\(.path)"' || echo "")
            echo "ðŸ“‹ Available workflows:"
            echo "$ALL_WORKFLOWS" | head -10
            
            # Try to find workflow with "release" in name
            RELEASE_WORKFLOW_ID=$(echo "$ALL_WORKFLOWS" | grep -i "release\|auto" | head -1 | cut -d'|' -f2 || echo "")
            if [ -n "$RELEASE_WORKFLOW_ID" ]; then
              echo "âœ… Found workflow ID: $RELEASE_WORKFLOW_ID"
              WORKFLOW_RUNS=$(gh run list --workflow="$RELEASE_WORKFLOW_ID" --limit 20 --json databaseId,conclusion,createdAt,displayTitle --jq '.[] | select(.conclusion == "success") | "\(.databaseId)|\(.createdAt)|\(.displayTitle)"' 2>/dev/null || echo "")
            fi
          fi
          
          # If still not found, try to get all successful runs and filter
          if [ -z "$WORKFLOW_RUNS" ]; then
            echo "âš ï¸  Trying to find any successful runs..."
            WORKFLOW_RUNS=$(gh run list --limit 50 --json databaseId,conclusion,createdAt,displayTitle,workflowName --jq '.[] | select(.conclusion == "success" and (.workflowName | test("release|auto"; "i"))) | "\(.databaseId)|\(.createdAt)|\(.displayTitle)"' 2>/dev/null || echo "")
          fi
          
          if [ -z "$WORKFLOW_RUNS" ]; then
            echo "âŒ No successful Auto Release workflow runs found"
            exit 1
          fi
          
          echo "ðŸ“‹ Found successful workflow runs:"
          echo "$WORKFLOW_RUNS" | head -5
          echo ""
          
          # Try to find a run with artifacts first
          FOUND_RUN_ID=""
          for run_info in $WORKFLOW_RUNS; do
            RUN_ID=$(echo "$run_info" | cut -d'|' -f1)
            CREATED_AT=$(echo "$run_info" | cut -d'|' -f2)
            TITLE=$(echo "$run_info" | cut -d'|' -f3-)
            
            echo "  Checking run $RUN_ID ($CREATED_AT)..."
            
            # Check if this run has artifacts using API
            ARTIFACTS=$(gh api repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts --jq '.artifacts[] | .name' 2>/dev/null || echo "")
            
            if [ -n "$ARTIFACTS" ] && [ "$ARTIFACTS" != "" ]; then
              FOUND_RUN_ID="$RUN_ID"
              echo "âœ… Found successful run with artifacts: $RUN_ID"
              echo "   Artifacts:"
              echo "$ARTIFACTS" | while read -r artifact; do
                if [ -n "$artifact" ]; then
                  echo "     - $artifact"
                fi
              done
              break
            else
              echo "   No artifacts found"
            fi
          done
          
          # If no artifacts found, try to find release with APK from these runs
          if [ -z "$FOUND_RUN_ID" ]; then
            echo "âš ï¸  No artifacts found in workflow runs, checking releases..."
            
            # Get all releases and find one with APK
            ALL_RELEASES=$(gh release list --limit 20 --json tagName,createdAt --jq '.[] | "\(.tagName)|\(.createdAt)"' || echo "")
            
            if [ -z "$ALL_RELEASES" ]; then
              echo "âŒ No releases found"
              exit 1
            fi
            
            # Function to check if release has APK
            check_release_has_apk() {
              local tag=$1
              local release_info=$(gh release view "$tag" --json assets 2>/dev/null)
              local exit_code=$?
              
              if [ $exit_code -ne 0 ] || [ -z "$release_info" ]; then
                echo "âš ï¸  Failed to get release info for $tag" >&2
                return 1
              fi
              
              # Check if release has any assets
              local asset_count=$(echo "$release_info" | jq -r '.assets | length' 2>/dev/null || echo "0")
              if [ "$asset_count" = "0" ] || [ -z "$asset_count" ]; then
                return 1
              fi
              
              # Find APK asset
              local apk_asset=$(echo "$release_info" | jq -r '.assets[] | select(.name | endswith(".apk")) | .name' 2>/dev/null | head -1)
              
              if [ -n "$apk_asset" ] && [ "$apk_asset" != "null" ] && [ "$apk_asset" != "" ]; then
                echo "$apk_asset"
                return 0
              fi
              
              return 1
            }
            
            # Check each release for APK
            FOUND_RELEASE_TAG=""
            FOUND_APK_NAME=""
            for release_info in $ALL_RELEASES; do
              RELEASE_TAG=$(echo "$release_info" | cut -d'|' -f1)
              CREATED_AT=$(echo "$release_info" | cut -d'|' -f2)
              
              echo "  Checking release $RELEASE_TAG ($CREATED_AT)..."
              
              # Use set +e to continue on error
              set +e
              APK_ASSET=$(check_release_has_apk "$RELEASE_TAG" 2>&1)
              local check_exit=$?
              set -e
              
              if [ $check_exit -eq 0 ] && [ -n "$APK_ASSET" ]; then
                FOUND_RELEASE_TAG="$RELEASE_TAG"
                FOUND_APK_NAME="$APK_ASSET"
                echo "âœ… Found release with APK: $FOUND_RELEASE_TAG"
                echo "   APK: $FOUND_APK_NAME"
                break
              else
                if [ -n "$APK_ASSET" ] && echo "$APK_ASSET" | grep -q "âš ï¸"; then
                  echo "$APK_ASSET"
                else
                  echo "   No APK found in this release"
                fi
              fi
            done
            
            if [ -z "$FOUND_RELEASE_TAG" ]; then
              echo "âŒ No release with APK found"
              exit 1
            fi
            
            echo "release_tag=$FOUND_RELEASE_TAG" >> $GITHUB_OUTPUT
            echo "apk_name=$FOUND_APK_NAME" >> $GITHUB_OUTPUT
            echo "use_release=true" >> $GITHUB_OUTPUT
          else
            echo "run_id=$FOUND_RUN_ID" >> $GITHUB_OUTPUT
            echo "use_release=false" >> $GITHUB_OUTPUT
          fi

      - name: Find Rust Build Workflow Run
        id: find_rust_workflow
        run: |
          echo "ðŸ” Finding successful Rust build workflow run..."
          
          # Get workflow file name
          RUST_WORKFLOW_FILE=".github/workflows/rust-build.yml"
          
          # Get successful workflow runs for rust-build workflow
          RUST_WORKFLOW_RUNS=$(gh run list --workflow="$RUST_WORKFLOW_FILE" --limit 10 --json databaseId,conclusion,createdAt,displayTitle --jq '.[] | select(.conclusion == "success") | "\(.databaseId)|\(.createdAt)|\(.displayTitle)"' 2>/dev/null || echo "")
          
          if [ -z "$RUST_WORKFLOW_RUNS" ]; then
            echo "âš ï¸  No successful Rust build workflow runs found"
            echo "rust_run_id=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "ðŸ“‹ Found successful Rust workflow runs:"
          echo "$RUST_WORKFLOW_RUNS" | head -3
          echo ""
          
          # Get the most recent successful run
          RUST_RUN_ID=$(echo "$RUST_WORKFLOW_RUNS" | head -1 | cut -d'|' -f1)
          
          # Check if this run has artifacts
          ARTIFACTS=$(gh api repos/${{ github.repository }}/actions/runs/$RUST_RUN_ID/artifacts --jq '.artifacts[] | .name' 2>/dev/null || echo "")
          
          if [ -n "$ARTIFACTS" ] && echo "$ARTIFACTS" | grep -q "rust-libs"; then
            echo "âœ… Found Rust build run with artifacts: $RUST_RUN_ID"
            echo "   Artifacts:"
            echo "$ARTIFACTS" | grep "rust-libs" | while read -r artifact; do
              if [ -n "$artifact" ]; then
                echo "     - $artifact"
              fi
            done
            echo "rust_run_id=$RUST_RUN_ID" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸  Rust build run $RUST_RUN_ID has no rust-libs artifacts"
            echo "rust_run_id=" >> $GITHUB_OUTPUT
          fi

      - name: Download Artifacts from Workflow Run
        id: download_artifacts
        run: |
          RUN_ID="${{ steps.find_workflow.outputs.run_id }}"
          
          if [ -z "$RUN_ID" ]; then
            echo "âŒ No workflow run ID found"
            exit 1
          fi
          
          echo "ðŸ“¥ Downloading artifacts from workflow run $RUN_ID..."
          
          mkdir -p artifacts-temp
          
          # Download all artifacts from the workflow run
          gh run download "$RUN_ID" --dir artifacts-temp/ || {
            echo "âŒ Failed to download artifacts from workflow run"
            exit 1
          }
          
          echo "ðŸ“¦ Downloaded artifacts:"
          find artifacts-temp -type f -exec ls -lh {} \; 2>/dev/null | head -20 || echo "  No files found"
          
          # List artifact directories
          echo "ðŸ“ Artifact directories:"
          ls -la artifacts-temp/ || echo "  No directories found"

      - name: Download Rust Libraries from CI
        id: download_rust_libs
        run: |
          RUST_RUN_ID="${{ steps.find_rust_workflow.outputs.rust_run_id }}"
          
          if [ -z "$RUST_RUN_ID" ]; then
            echo "âš ï¸  No Rust build workflow run ID found, skipping Rust libraries download"
            echo "rust_libs_available=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "ðŸ“¥ Downloading Rust libraries from workflow run $RUST_RUN_ID..."
          
          mkdir -p artifacts-temp/rust-libs
          
          # Download Rust artifacts
          gh run download "$RUST_RUN_ID" --pattern "rust-libs-*" --dir artifacts-temp/rust-libs/ || {
            echo "âš ï¸  Failed to download Rust libraries from workflow run"
            echo "rust_libs_available=false" >> $GITHUB_OUTPUT
            exit 0
          }
          
          echo "ðŸ“¦ Downloaded Rust artifacts:"
          find artifacts-temp/rust-libs -type f -exec ls -lh {} \; 2>/dev/null | head -20 || echo "  No files found"
          
          # List artifact directories
          echo "ðŸ“ Rust artifact directories:"
          ls -la artifacts-temp/rust-libs/ || echo "  No directories found"
          
          echo "rust_libs_available=true" >> $GITHUB_OUTPUT

      - name: Set up Java 21
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"
          cache: "gradle"

      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      - name: Setup Keystore and Properties
        env:
          KEYSTORE_PASSWORD: ${{ secrets.SIGNING_STORE_PASSWORD }}
          KEY_PASSWORD: ${{ secrets.SIGNING_KEY_PASSWORD }}
        run: |
          echo "${{ secrets.SIGNING_KEYSTORE }}" > keystore.b64
          base64 -d keystore.b64 > ./store.jks
          rm keystore.b64
          echo "storeFile=store.jks" > ./store.properties
          echo "storePassword=${{ secrets.SIGNING_STORE_PASSWORD }}" >> ./store.properties
          echo "keyAlias=${{ secrets.SIGNING_KEY_ALIAS }}" >> ./store.properties
          echo "keyPassword=${{ secrets.SIGNING_KEY_PASSWORD }}" >> ./store.properties

      - name: Copy Rust Libraries from CI Artifacts
        if: steps.download_rust_libs.outputs.rust_libs_available == 'true'
        run: |
          echo "ðŸ“¦ Copying Rust libraries from CI artifacts..."
          
          # Ensure jniLibs directory structure exists
          mkdir -p app/src/main/jniLibs/arm64-v8a
          mkdir -p app/src/main/jniLibs/armeabi-v7a
          mkdir -p app/src/main/jniLibs/x86_64
          mkdir -p app/src/main/jniLibs/x86
          
          # Rust modules to copy
          rust_modules="xray-signal-handler pepper-shaper perf-net quiche-client"
          
          # Copy Rust libraries for each target
          # aarch64-linux-android -> arm64-v8a
          if [ -d "artifacts-temp/rust-libs/rust-libs-aarch64-linux-android" ]; then
            echo "ðŸ“‹ Copying Rust libraries for aarch64-linux-android (ABI: arm64-v8a)..."
            for module in $rust_modules; do
              lib_file="artifacts-temp/rust-libs/rust-libs-aarch64-linux-android/lib$module.so"
              if [ -f "$lib_file" ]; then
                cp "$lib_file" "app/src/main/jniLibs/arm64-v8a/lib$module.so"
                echo "   âœ… Copied lib$module.so to arm64-v8a"
              else
                echo "   âš ï¸  lib$module.so not found"
              fi
            done
          fi
          
          # armv7-linux-androideabi -> armeabi-v7a
          if [ -d "artifacts-temp/rust-libs/rust-libs-armv7-linux-androideabi" ]; then
            echo "ðŸ“‹ Copying Rust libraries for armv7-linux-androideabi (ABI: armeabi-v7a)..."
            for module in $rust_modules; do
              lib_file="artifacts-temp/rust-libs/rust-libs-armv7-linux-androideabi/lib$module.so"
              if [ -f "$lib_file" ]; then
                cp "$lib_file" "app/src/main/jniLibs/armeabi-v7a/lib$module.so"
                echo "   âœ… Copied lib$module.so to armeabi-v7a"
              else
                echo "   âš ï¸  lib$module.so not found"
              fi
            done
          fi
          
          # x86_64-linux-android -> x86_64
          if [ -d "artifacts-temp/rust-libs/rust-libs-x86_64-linux-android" ]; then
            echo "ðŸ“‹ Copying Rust libraries for x86_64-linux-android (ABI: x86_64)..."
            for module in $rust_modules; do
              lib_file="artifacts-temp/rust-libs/rust-libs-x86_64-linux-android/lib$module.so"
              if [ -f "$lib_file" ]; then
                cp "$lib_file" "app/src/main/jniLibs/x86_64/lib$module.so"
                echo "   âœ… Copied lib$module.so to x86_64"
              else
                echo "   âš ï¸  lib$module.so not found"
              fi
            done
          fi
          
          # i686-linux-android -> x86
          if [ -d "artifacts-temp/rust-libs/rust-libs-i686-linux-android" ]; then
            echo "ðŸ“‹ Copying Rust libraries for i686-linux-android (ABI: x86)..."
            for module in $rust_modules; do
              lib_file="artifacts-temp/rust-libs/rust-libs-i686-linux-android/lib$module.so"
              if [ -f "$lib_file" ]; then
                cp "$lib_file" "app/src/main/jniLibs/x86/lib$module.so"
                echo "   âœ… Copied lib$module.so to x86"
              else
                echo "   âš ï¸  lib$module.so not found"
              fi
            done
          fi
          
          echo "âœ… Rust libraries copy complete"
          
          # Verify Rust libraries
          echo "ðŸ“‹ Verifying Rust libraries:"
          for abi in arm64-v8a armeabi-v7a x86_64 x86; do
            rust_libs=$(find app/src/main/jniLibs/$abi -name "libxray-signal-handler.so" -o -name "libpepper-shaper.so" -o -name "libperf-net.so" -o -name "libquiche-client.so" 2>/dev/null | wc -l)
            if [ "$rust_libs" -gt 0 ]; then
              echo "   âœ… $abi: $rust_libs Rust libraries found"
            else
              echo "   âš ï¸  $abi: No Rust libraries found"
            fi
          done

      - name: Copy Native Libraries from Artifacts
        run: |
          echo "ðŸ“¦ Copying native libraries from artifacts..."
          
          # Ensure jniLibs directory structure exists
          mkdir -p app/src/main/jniLibs/arm64-v8a
          mkdir -p app/src/main/jniLibs/x86_64
          
          # Copy Xray libraries
          if [ -d "artifacts-temp/xray-arm64-v8a" ]; then
            cp artifacts-temp/xray-arm64-v8a/libxray.so app/src/main/jniLibs/arm64-v8a/ 2>/dev/null || echo "âš ï¸  libxray.so not found in xray-arm64-v8a"
            echo "âœ… Copied Xray library for arm64-v8a"
          fi
          
          if [ -d "artifacts-temp/xray-x86_64" ]; then
            cp artifacts-temp/xray-x86_64/libxray.so app/src/main/jniLibs/x86_64/ 2>/dev/null || echo "âš ï¸  libxray.so not found in xray-x86_64"
            echo "âœ… Copied Xray library for x86_64"
          fi
          
          # Copy Hysteria2 libraries
          if [ -d "artifacts-temp/hysteria2-arm64-v8a" ]; then
            cp artifacts-temp/hysteria2-arm64-v8a/libhysteria2.so app/src/main/jniLibs/arm64-v8a/ 2>/dev/null || echo "âš ï¸  libhysteria2.so not found in hysteria2-arm64-v8a"
            echo "âœ… Copied Hysteria2 library for arm64-v8a"
          fi
          
          if [ -d "artifacts-temp/hysteria2-x86_64" ]; then
            cp artifacts-temp/hysteria2-x86_64/libhysteria2.so app/src/main/jniLibs/x86_64/ 2>/dev/null || echo "âš ï¸  libhysteria2.so not found in hysteria2-x86_64"
            echo "âœ… Copied Hysteria2 library for x86_64"
          fi
          
          # Copy QUICHE libraries
          if [ -d "artifacts-temp/quiche-arm64-v8a" ]; then
            mkdir -p app/src/main/jni/quiche-client/libs/arm64-v8a
            cp artifacts-temp/quiche-arm64-v8a/libquiche.a app/src/main/jni/quiche-client/libs/arm64-v8a/ 2>/dev/null || echo "âš ï¸  libquiche.a not found"
            cp artifacts-temp/quiche-arm64-v8a/libquiche.so app/src/main/jni/quiche-client/libs/arm64-v8a/ 2>/dev/null || echo "âš ï¸  libquiche.so not found"
            echo "âœ… Copied QUICHE libraries for arm64-v8a"
          fi
          
          if [ -d "artifacts-temp/quiche-x86_64" ]; then
            mkdir -p app/src/main/jni/quiche-client/libs/x86_64
            cp artifacts-temp/quiche-x86_64/libquiche.a app/src/main/jni/quiche-client/libs/x86_64/ 2>/dev/null || echo "âš ï¸  libquiche.a not found"
            cp artifacts-temp/quiche-x86_64/libquiche.so app/src/main/jni/quiche-client/libs/x86_64/ 2>/dev/null || echo "âš ï¸  libquiche.so not found"
            echo "âœ… Copied QUICHE libraries for x86_64"
          fi
          
          # Verify all libraries
          echo "ðŸ“‹ Verifying all native libraries:"
          find app/src/main/jniLibs -name "*.so" -type f 2>/dev/null | head -20 || echo "âš ï¸  No .so files found"
          find app/src/main/jni/quiche-client/libs -name "libquiche.*" -type f 2>/dev/null | head -10 || echo "âš ï¸  No QUICHE libraries found"

      - name: Copy BoringSSL Libraries from Artifacts for QUICHE
        run: |
          echo "ðŸ“¦ Copying BoringSSL libraries from artifacts for QUICHE..."
          
          # Check if QUICHE library exists - if not, we don't need BoringSSL
          QUICHE_LIB="app/src/main/jni/quiche-client/libs/arm64-v8a/libquiche.a"
          if [ ! -f "$QUICHE_LIB" ]; then
            echo "âš ï¸  QUICHE library not found at $QUICHE_LIB"
            echo "   QUICHE build will be skipped, BoringSSL not needed"
            exit 0
          fi
          
          echo "âœ… QUICHE library found, checking for BoringSSL artifacts..."
          
          # BoringSSL path where Android.mk expects it
          BORINGSSL_BUILD_DIR="app/src/main/jni/quiche-client/third_party/quiche/quiche/deps/boringssl/build"
          
          # Check for BoringSSL artifacts in downloaded artifacts
          if [ -d "artifacts-temp/boringssl-arm64-v8a" ]; then
            echo "âœ… Found BoringSSL artifact for arm64-v8a"
            
            # Create directory structure
            mkdir -p "$BORINGSSL_BUILD_DIR/crypto"
            mkdir -p "$BORINGSSL_BUILD_DIR/ssl"
            
            # Copy BoringSSL libraries from artifact
            if [ -f "artifacts-temp/boringssl-arm64-v8a/crypto/libcrypto.a" ]; then
              cp artifacts-temp/boringssl-arm64-v8a/crypto/libcrypto.a "$BORINGSSL_BUILD_DIR/crypto/libcrypto.a"
              echo "âœ… Copied libcrypto.a to $BORINGSSL_BUILD_DIR/crypto/"
            else
              echo "âŒ libcrypto.a not found in artifact"
              exit 1
            fi
            
            if [ -f "artifacts-temp/boringssl-arm64-v8a/ssl/libssl.a" ]; then
              cp artifacts-temp/boringssl-arm64-v8a/ssl/libssl.a "$BORINGSSL_BUILD_DIR/ssl/libssl.a"
              echo "âœ… Copied libssl.a to $BORINGSSL_BUILD_DIR/ssl/"
            else
              echo "âŒ libssl.a not found in artifact"
              exit 1
            fi
            
            # Verify libraries are in place
            if [ -f "$BORINGSSL_BUILD_DIR/crypto/libcrypto.a" ] && [ -f "$BORINGSSL_BUILD_DIR/ssl/libssl.a" ]; then
              echo "âœ… BoringSSL libraries verified at expected paths:"
              ls -lh "$BORINGSSL_BUILD_DIR/crypto/libcrypto.a" "$BORINGSSL_BUILD_DIR/ssl/libssl.a"
            else
              echo "âŒ BoringSSL libraries verification failed"
              exit 1
            fi
          else
            echo "âš ï¸  BoringSSL artifact not found for arm64-v8a"
            echo "   QUICHE build may fail without BoringSSL libraries"
            echo "ðŸ“‹ Available artifacts:"
            ls -la artifacts-temp/ 2>/dev/null | head -20 || echo "  No artifacts found"
            exit 1
          fi

      - name: Download Rules Files
        run: |
          if [ -f "version.properties" ]; then
            GEOIP_VERSION=$(grep 'GEOIP_VERSION' version.properties | cut -d '=' -f 2)
            GEOSITE_VERSION=$(grep 'GEOSITE_VERSION' version.properties | cut -d '=' -f 2)
          else
            # Use default versions if not found
            GEOIP_VERSION="202411080001"
            GEOSITE_VERSION="202411080001"
          fi
          
          if [ -z "$GEOIP_VERSION" ] || [ -z "$GEOSITE_VERSION" ]; then
            echo "âš ï¸  GEOIP_VERSION or GEOSITE_VERSION not set, using defaults"
            GEOIP_VERSION="202411080001"
            GEOSITE_VERSION="202411080001"
          fi
          
          mkdir -p app/src/main/assets
          wget https://github.com/lhear/v2ray-rules-dat/releases/download/$GEOIP_VERSION/geoip.dat -O ./app/src/main/assets/geoip.dat || echo "âš ï¸  Failed to download geoip.dat"
          wget https://github.com/lhear/v2ray-rules-dat/releases/download/$GEOSITE_VERSION/geosite.dat -O ./app/src/main/assets/geosite.dat || echo "âš ï¸  Failed to download geosite.dat"

      - name: Make gradlew executable
        run: chmod +x ./gradlew

      - name: Build Release APK
        env:
          KEYSTORE_PASSWORD: ${{ secrets.SIGNING_STORE_PASSWORD }}
          KEY_PASSWORD: ${{ secrets.SIGNING_KEY_PASSWORD }}
        run: |
          echo "ðŸ”¨ Building release APK with downloaded artifacts..."
          
          set +e
          ./gradlew assembleRelease --stacktrace --warning-mode all 2>&1 | tee gradle-build.log
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          set -e
          
          if [ "$BUILD_EXIT_CODE" -ne 0 ]; then
            echo "âŒ Build failed with exit code: $BUILD_EXIT_CODE"
            echo ""
            echo "=== Last 100 lines of Gradle output ==="
            tail -100 gradle-build.log || echo "Could not read build log"
            exit 1
          fi
          
          echo "âœ… Build completed"
          
          # Verify APK was generated
          if [ -f "app/build/outputs/apk/release/simplexray-arm64-v8a.apk" ]; then
            APK_SIZE=$(stat -c%s "app/build/outputs/apk/release/simplexray-arm64-v8a.apk" 2>/dev/null || echo "0")
            APK_SIZE_MB=$((APK_SIZE / 1024 / 1024))
            echo "âœ… APK generated: simplexray-arm64-v8a.apk (${APK_SIZE_MB}MB)"
            echo "apk_name=simplexray-arm64-v8a.apk" >> $GITHUB_OUTPUT
            echo "apk_path=app/build/outputs/apk/release/simplexray-arm64-v8a.apk" >> $GITHUB_OUTPUT
          else
            echo "âŒ APK not found at expected location"
            find app/build -name "*.apk" -type f 2>/dev/null | head -10 || echo "No APKs found"
            exit 1
          fi

      - name: Copy APK to Release Artifacts
        run: |
          mkdir -p release-artifacts
          cp app/build/outputs/apk/release/simplexray-arm64-v8a.apk release-artifacts/
          echo "âœ… APK copied to release-artifacts/"
          ls -lh release-artifacts/

      - name: Read Version from Properties
        id: version
        run: |
          if [ -f "version.properties" ]; then
            VERSION_NAME=$(grep 'APP_VERSION_NAME' version.properties | cut -d '=' -f 2)
            VERSION_CODE=$(grep 'APP_VERSION_CODE' version.properties | cut -d '=' -f 2)
          else
            # Use current date as version if properties not found
            VERSION_NAME=$(date +"%Y.%m.%d")
            VERSION_CODE="1"
          fi
          
          TEST_SUFFIX="${{ inputs.test_version_suffix }}"
          TEST_VERSION_NAME="${VERSION_NAME}${TEST_SUFFIX}"
          
          echo "version_name=$VERSION_NAME" >> $GITHUB_OUTPUT
          echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT
          echo "test_version_name=$TEST_VERSION_NAME" >> $GITHUB_OUTPUT
          echo "tag=v${TEST_VERSION_NAME}" >> $GITHUB_OUTPUT
          
          echo "ðŸ“‹ Version Information:"
          echo "  Original Version: $VERSION_NAME"
          echo "  Test Version: $TEST_VERSION_NAME"
          echo "  Test Tag: v${TEST_VERSION_NAME}"

      - name: Check if Test Tag Exists
        id: check_tag
        run: |
          TEST_TAG="v${{ steps.version.outputs.test_version_name }}"
          if git ls-remote --tags origin | grep -q "refs/tags/${TEST_TAG}$"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âš ï¸  Tag $TEST_TAG already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âœ… Tag $TEST_TAG does not exist, proceeding"
          fi

      - name: Create Test Release
        if: steps.check_tag.outputs.exists == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TEST_TAG="v${{ steps.version.outputs.test_version_name }}"
          RUN_ID="${{ steps.find_workflow.outputs.run_id }}"
          VERSION_NAME="${{ steps.version.outputs.test_version_name }}"
          BUILD_CODE="${{ steps.version.outputs.version_code }}"
          COMMIT="${{ github.sha }}"
          APK_PATH="release-artifacts/simplexray-arm64-v8a.apk"
          APK_NAME="simplexray-arm64-v8a.apk"
          
          SOURCE_INFO="Workflow Run $RUN_ID (APK built from artifacts)"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Create and push tag
          git tag -a "$TEST_TAG" -m "Test Release $TEST_TAG (from $SOURCE_INFO)"
          git push origin "$TEST_TAG"
          
          # Create release notes
          RUST_RUN_ID="${{ steps.find_rust_workflow.outputs.rust_run_id }}"
          if [ -n "$RUST_RUN_ID" ]; then
            RUST_INFO="
          **Rust Libraries:** Built from Rust CI workflow run $RUST_RUN_ID
            - xray-signal-handler
            - pepper-shaper
            - perf-net
            - quiche-client"
          else
            RUST_INFO=""
          fi
          
          cat > release_notes.md << EOF
          ðŸ§ª Test Release for version ${VERSION_NAME}
          
          **Source:** ${SOURCE_INFO}
          **Test Version:** ${TEST_VERSION_NAME}
          **Build Code:** ${BUILD_CODE}
          **Commit:** ${COMMIT}${RUST_INFO}
          
          **Note:** This is a test release. APK was built using native libraries from ${SOURCE_INFO}.
          Native libraries (Xray, Hysteria2, QUICHE, BoringSSL) were downloaded from the workflow run and used to build the APK.$([ -n "$RUST_RUN_ID" ] && echo " Rust native modules were downloaded from Rust CI workflow run $RUST_RUN_ID and used in the build.")
          
          **Download APK:**
          - \`${APK_NAME}\` - For most modern devices (ARM64) - BoringSSL optimized
          
          **Features:**
          - ðŸ”’ BoringSSL integration (replaces OpenSSL)
          - âš¡ Hardware-accelerated crypto (AES-GCM, ChaCha20-Poly1305)
          - ðŸš€ TLS 1.3 with Chrome mobile fingerprint mimic
          - ðŸ“¡ QUIC/HTTP3 support
          - ðŸŽ¯ Xray-core built with BoringSSL (3-40x faster crypto performance)
          - ðŸŒŠ Hysteria2 QUIC acceleration (standalone or chain mode)
          
          ---
          ðŸ¤– Auto-generated test release from ${SOURCE_INFO}
          EOF
          
          # Create release with APK
          if [ -n "$APK_PATH" ] && [ -f "$APK_PATH" ]; then
            echo "ðŸ“¦ Creating test release with APK..."
            gh release create "$TEST_TAG" \
              --title "SimpleXray Test Release $TEST_TAG" \
              --notes-file release_notes.md \
              --prerelease \
              "$APK_PATH"
            
            echo "âœ… Test release created: https://github.com/${{ github.repository }}/releases/tag/$TEST_TAG"
          else
            echo "âŒ APK file not found: $APK_PATH"
            echo "ðŸ“ Available files in release-artifacts/:"
            ls -lah release-artifacts/ || echo "Directory does not exist"
            exit 1
          fi

      - name: Send Test Release Notification to Telegram
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          BOT_TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}"
          CHAT_ID="${{ secrets.TELEGRAM_CHAT_ID }}"
          
          if [ -z "$BOT_TOKEN" ] || [ -z "$CHAT_ID" ]; then
            echo "âš ï¸  Telegram secrets not configured, skipping notification"
            exit 0
          fi
          
          TEST_TAG="v${{ steps.version.outputs.test_version_name }}"
          RUN_ID="${{ steps.find_workflow.outputs.run_id }}"
          RUST_RUN_ID="${{ steps.find_rust_workflow.outputs.rust_run_id }}"
          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/$TEST_TAG"
          
          RUST_INFO=""
          if [ -n "$RUST_RUN_ID" ]; then
            RUST_INFO="\nðŸ”§ *Rust Libraries:* CI Run $RUST_RUN_ID"
          fi
          
          TEXT="ðŸ§ª *Test Release Created*\n\nðŸ“¦ *Version:* $TEST_TAG\nðŸ“‹ *Source:* Workflow Run $RUN_ID$RUST_INFO\nðŸ”¨ *Build:* ${{ steps.version.outputs.version_code }}\n\nâ„¹ï¸ *Note:* This is a test release. APK was built using native libraries from workflow run $RUN_ID.$([ -n "$RUST_RUN_ID" ] && echo " Rust modules from CI run $RUST_RUN_ID.")\n\nðŸ”— [Download Test Release]($RELEASE_URL)"
          
          curl -s -X POST \
            -H "Content-Type: application/json" \
            -d "{\"chat_id\": \"$CHAT_ID\", \"text\": \"$TEXT\", \"parse_mode\": \"Markdown\"}" \
            "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" || echo "âš ï¸  Failed to send Telegram notification"

