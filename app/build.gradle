plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
    id 'org.jetbrains.kotlin.plugin.compose'
    id 'com.google.protobuf' version '0.9.4'
    id 'com.google.devtools.ksp'
    id 'com.google.gms.google-services'
    id 'com.google.firebase.crashlytics'
}

// Create dummy google-services.json if it doesn't exist (for CI builds)
def googleServicesFile = file('google-services.json')
if (!googleServicesFile.exists()) {
    def debugFile = file('src/debug/google-services.json')
    def mainFile = file('src/google-services.json')
    
    if (!debugFile.exists() && !mainFile.exists()) {
        println "âš ï¸  google-services.json not found - creating dummy file for build"
        googleServicesFile.parentFile.mkdirs()
        googleServicesFile.text = '''{
  "project_info": {
    "project_number": "000000000000",
    "project_id": "dummy-project",
    "storage_bucket": "dummy-project.appspot.com"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:000000000000:android:0000000000000000000000",
        "android_client_info": {
          "package_name": "com.simplexray.an"
        }
      },
      "oauth_client": [],
      "api_key": [
        {
          "current_key": "AIzaSyDummy-Key-For-CI-Build-Only"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": []
        }
      }
    }
  ],
  "configuration_version": "1"
}'''
    }
}

protobuf {
    protoc {
        artifact = 'com.google.protobuf:protoc:3.25.1'
    }
    plugins {
        grpc {
            artifact = 'io.grpc:protoc-gen-grpc-java:1.75.0'
        }
        grpc_kotlin {
            artifact = 'io.grpc:protoc-gen-grpc-kotlin:1.5.0:jdk8'
        }
        grpckt {
            artifact = 'io.grpc:protoc-gen-grpc-kotlin:1.5.0:jdk8@jar'
        }
    }
    generateProtoTasks {
        all().each { task ->
            task.builtins {
                java {}
            }
            task.plugins {
                grpc {}
                grpckt {}
            }
        }
    }
}

def versionProps = new Properties()
file("$rootDir/version.properties").withInputStream { versionProps.load(it) }

android {
    namespace "com.simplexray.an"
    compileSdk = 36

    defaultConfig {
        applicationId "com.simplexray.an"
        versionCode versionProps.APP_VERSION_CODE.toInteger()
        versionName versionProps.APP_VERSION_NAME

        // Runtime SSL mode configuration
        def sslMode = System.getenv("SXR_SSL_MODE") ?: "boringssl"
        resValue "string", "sxr_ssl_mode", sslMode
        buildConfigField "String", "SXR_SSL_MODE", "\"${sslMode}\""

        // Always use BoringSSL (OpenSSL removed)
        buildConfigField "boolean", "USE_BORINGSSL", "true"
        println "ðŸ”’ Building with BoringSSL"

        // Experimental features (debug only)
        def isRelease = gradle.startParameter.taskNames.any { it.contains("Release") }
        buildConfigField "boolean", "EXPERIMENTAL_ENABLED", "${!isRelease}"

        targetSdk = 35
        minSdk = 29

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"

        // BuildConfig fields for update mechanism
        buildConfigField "String", "REPOSITORY_URL", "\"https://github.com/halibiram/SimpleXray\""
        buildConfigField "String[]", "SUPPORTED_ABIS", "new String[]{\"arm64-v8a\", \"x86_64\"}"
        buildConfigField "boolean", "FEAT_STREAMING_PANEL", "false" // Feature flag for streaming panel UI
        buildConfigField "boolean", "FEAT_GAME_PANEL", "false" // Feature flag for game optimization panel UI
        buildConfigField "boolean", "FEAT_PERF_PANEL", "false" // Feature flag for performance diagnostics panel
        buildConfigField "boolean", "FEAT_HYPER_UI", "false" // Feature flag for hyper UI performance components

        // Crypto library build status (BoringSSL only)
        def boringsslAvailable = file("../external/boringssl/lib/arm64-v8a/libcrypto.a").exists()
        buildConfigField "boolean", "BORINGSSL_AVAILABLE_AT_BUILD", "${boringsslAvailable}"
        buildConfigField "boolean", "OPENSSL_AVAILABLE_AT_BUILD", "false"

        // NDK build configuration - Pass correct package and class names to JNI
        externalNativeBuild {
            ndkBuild {
                // CRITICAL: Pass correct package and class names to JNI for FindClass
                arguments "PKGNAME=com/simplexray/an/service", "CLSNAME=TProxyService"
                cFlags "-DPKGNAME=com/simplexray/an/service", "-DCLSNAME=TProxyService"
            }
        }
    }

    signingConfigs {
        release {
            enableV1Signing = true
            enableV2Signing = true
            enableV3Signing = true
            // SEC: V4 signing disabled - may affect Android 11+ compatibility
        // TODO: Enable V4 signing for Android 11+ devices
        // UPGRADE-RISK: V4 signing required for Android 11+ - may cause installation issues
            enableV4Signing = false
        }
    }

    buildTypes {
        release {
            minifyEnabled true
            shrinkResources = true
            signingConfig = signingConfigs.release
            proguardFiles(
                    getDefaultProguardFile('proguard-android-optimize.txt'),
                    'proguard-rules.pro'
            )
        }
        debug {
            minifyEnabled false
            signingConfig = signingConfigs.release
            debuggable true
        }
    }

    // COMPAT: JavaVersion.VERSION_21 is required for Android SDK 35
    // Verified: Java 21 is fully compatible with Android SDK 35 and required for modern Android development
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_21
        targetCompatibility JavaVersion.VERSION_21
    }

    // SEC: Signing config loaded from file - ensure store.properties is not committed
    def propsFile = rootProject.file('store.properties')
    def configName = 'release'

    if (propsFile.exists() && signingConfigs.hasProperty(configName)) {
        def props = new Properties()
        props.load(new FileInputStream(propsFile))
        if (props != null && props.containsKey('storeFile')) {
            signingConfigs.named(configName).configure { signingConfig ->
                // Validate storeFile path to prevent loading wrong file
                def storeFilePath = props['storeFile']
                if (storeFilePath == null || storeFilePath.isEmpty()) {
                    throw new RuntimeException("storeFile path is empty in store.properties")
                }
                def storeFile = rootProject.file(storeFilePath)
                if (!storeFile.exists()) {
                    throw new RuntimeException("Store file not found: ${storeFile.absolutePath}")
                }
                if (!storeFile.isFile()) {
                    throw new RuntimeException("Store file path is not a file: ${storeFile.absolutePath}")
                }
                signingConfig.storeFile = storeFile
                
                // SEC: Passwords stored in plain text - prefer environment variables
                // TODO: Consider using Gradle encrypted properties or keychain
                // Use environment variables if available, fallback to properties file
                signingConfig.storePassword = System.getenv('KEYSTORE_PASSWORD') ?: props['storePassword']
                signingConfig.keyAlias = props['keyAlias']
                signingConfig.keyPassword = System.getenv('KEY_PASSWORD') ?: props['keyPassword']
                
                if (signingConfig.storePassword == null || signingConfig.storePassword.isEmpty()) {
                    throw new RuntimeException("Store password is required but not provided")
                }
                if (signingConfig.keyPassword == null || signingConfig.keyPassword.isEmpty()) {
                    throw new RuntimeException("Key password is required but not provided")
                }
            }
        }
    }

    externalNativeBuild {
        ndkBuild {
            path "src/main/jni/Android.mk"
        }
    }

    lint {
        // Enable lint checks for release builds but don't abort on errors
        // This allows builds to complete while still reporting issues
        checkReleaseBuilds = true
        // Continue the build even when errors are found (warnings only)
        // BUG: Lint errors don't block build - may ship code with issues
        // TODO: Consider enabling abortOnError=true for release builds
        // Note: abortOnError=false allows builds to complete but issues should be reviewed
        // TEST-GAP: Lint errors not caught in CI - may ship broken code
        abortOnError = false
        // Treat warnings as errors only in strict mode (not enabled by default)
        warningsAsErrors = false
    }

    // Note: extractNativeLibs is no longer supported in AGP 8.0+
    // Native libraries are extracted by default for APKs in AGP 8.0+
    
    // Legacy packaging options (kept for compatibility)
    packagingOptions {
        jniLibs {
            useLegacyPackaging = true
        }
    }

    dependenciesInfo {
        // Disables dependency metadata when building APKs.
        includeInApk = false
        // Disables dependency metadata when building Android App Bundles.
        includeInBundle = false
    }
    ndkVersion = versionProps.NDK_VERSION

    splits {
        abi {
            enable = true
            reset()
            include "arm64-v8a"  // Only build arm64-v8a for faster builds
            universalApk false
        }
    }

    applicationVariants.configureEach { variant ->
        variant.outputs.each { output ->
            def abiFilter = output.getFilter("ABI")
            if (abiFilter != null) {
                output.outputFileName = "simplexray-${abiFilter}.apk"
            } else {
                output.outputFileName = "simplexray-universal.apk"
            }
        }
    }

    buildFeatures {
        compose true
        buildConfig true
    }

    // COMPAT: jvmToolchain(21) requires JDK 21 - required for building this project
    // Note: JDK 21 is required for Android SDK 35 compatibility. Ensure JDK 21 is installed before building.
    kotlin {
        jvmToolchain(21)
    }

    sourceSets {
        main {
            java {
                srcDirs 'src/main/java', 'build/generated/source/proto/main/java'
            }
            kotlin {
                srcDirs 'src/main/kotlin', 'build/generated/source/proto/main/grpckt', 'build/generated/ksp/debug/kotlin', 'build/generated/ksp/release/kotlin'
            }
            // Ensure jniLibs and assets are included for debug builds
            jniLibs {
                srcDirs 'src/main/jniLibs'
            }
            assets {
                srcDirs 'src/main/assets'
            }
        }
        debug {
            // Debug build uses local files from jniLibs and assets
            jniLibs {
                srcDirs 'src/main/jniLibs'
            }
            assets {
                srcDirs 'src/main/assets'
            }
        }
    }
}

// Pre-build check for local debug files
tasks.register("checkDebugFiles") {
    doLast {
        def isDebugBuild = gradle.startParameter.taskNames.any { 
            it.contains("Debug") || it.contains("debug") 
        }
        
        if (isDebugBuild) {
            println("ðŸ” Checking local debug files...")
            
            // Check jniLibs
            def jniLibsDir = file("src/main/jniLibs")
            def hasJniLibs = jniLibsDir.exists() && jniLibsDir.listFiles()?.length > 0
            
            if (hasJniLibs) {
                println("âœ… Local jniLibs found: ${jniLibsDir.absolutePath}")
                jniLibsDir.listFiles()?.each { abiDir ->
                    if (abiDir.isDirectory()) {
                        def xrayLib = new File(abiDir, "libxray.so")
                        def hysteria2Lib = new File(abiDir, "libhysteria2.so")
                        if (xrayLib.exists()) {
                            println("   âœ… libxray.so found for ${abiDir.name} (${xrayLib.length()} bytes)")
                        }
                        if (hysteria2Lib.exists()) {
                            println("   âœ… libhysteria2.so found for ${abiDir.name} (${hysteria2Lib.length()} bytes)")
                        }
                    }
                }
            } else {
                println("âš ï¸  WARNING: Local jniLibs not found!")
                println("   Run: ./scripts/download-debug-files.ps1 (Windows) or ./scripts/download-debug-files.sh (Linux/Mac)")
                println("   Build will continue but may use fallback libraries.")
            }
            
            // Check assets
            def assetsDir = file("src/main/assets")
            def geoipFile = new File(assetsDir, "geoip.dat")
            def geositeFile = new File(assetsDir, "geosite.dat")
            
            if (geoipFile.exists() && geositeFile.exists()) {
                println("âœ… Local assets found:")
                println("   âœ… geoip.dat (${geoipFile.length()} bytes)")
                println("   âœ… geosite.dat (${geositeFile.length()} bytes)")
            } else {
                println("âš ï¸  WARNING: Local assets not found!")
                if (!geoipFile.exists()) {
                    println("   Missing: geoip.dat")
                }
                if (!geositeFile.exists()) {
                    println("   Missing: geosite.dat")
                }
                println("   Run: ./scripts/download-debug-files.ps1 (Windows) or ./scripts/download-debug-files.sh (Linux/Mac)")
            }
        }
    }
}

// Pre-build check for BoringSSL
tasks.register("checkBoringSSL") {
    doLast {
        def boringsslDir = file("../external/boringssl")
        def boringsslLibCryptoArm64 = file("../external/boringssl/lib/arm64-v8a/libcrypto.a")
        def boringsslLibSslArm64 = file("../external/boringssl/lib/arm64-v8a/libssl.a")
        
        def hasBoringSSL = boringsslLibCryptoArm64.exists() && 
                           boringsslLibSslArm64.exists()
        
        if (!hasBoringSSL) {
            println("âš ï¸  WARNING: BoringSSL libraries not found!")
            println("   BoringSSL directory: ${boringsslDir.absolutePath}")
            println("   Expected files:")
            println("     - ${boringsslLibCryptoArm64.absolutePath}")
            println("     - ${boringsslLibSslArm64.absolutePath}")
            println("")
            println("   To build BoringSSL:")
            println("   1. Run: ./external/boringssl/build_all_abis.py")
            println("   2. Or follow instructions in external/boringssl/README.md")
            println("")
            println("   Note: Build will continue but crypto features may not work.")
        } else {
            println("âœ… BoringSSL found: ${boringsslDir.absolutePath}")
        }
    }
}

// Copy QUICHE libraries from artifacts to quiche-client/libs/
tasks.register("copyQuicheLibraries") {
    doLast {
        def quicheClientLibsDir = file("src/main/jni/quiche-client/libs")
        def artifactsDir = file("../artifacts")
        
        def abis = ["arm64-v8a", "x86_64"]
        def copiedCount = 0
        
        abis.each { abi ->
            def sourceLib = file("${artifactsDir}/quiche-${abi}/libquiche.a")
            def targetDir = file("${quicheClientLibsDir}/${abi}")
            def targetLib = file("${targetDir}/libquiche.a")
            
            if (sourceLib.exists()) {
                targetDir.mkdirs()
                copy {
                    from sourceLib
                    into targetDir
                }
                println("âœ… Copied ${sourceLib.name} to ${targetDir.absolutePath}")
                copiedCount++
            } else {
                println("âš ï¸  QUICHE library not found at ${sourceLib.absolutePath}")
                println("   Expected location: artifacts/quiche-${abi}/libquiche.a")
            }
        }
        
        if (copiedCount > 0) {
            println("âœ… QUICHE libraries copied: ${copiedCount}/${abis.size()} ABIs")
        } else {
            println("âš ï¸  WARNING: No QUICHE libraries found in artifacts directory")
            println("   QUICHE native build will be skipped")
            println("   To build QUICHE:")
            println("   1. Run: cd app/src/main/jni/quiche-client && ./build-quiche-android.sh")
            println("   2. Or download from CI artifacts")
        }
    }
}

// Build Rust native modules
tasks.register("buildRustModules") {
    doLast {
        // Map module names to their Cargo library names and Kotlin load names
        def rustModules = [
            "xray-signal-handler": ["cargoLib": "xray_signal_handler", "kotlinName": "xray-signal-handler"],
            "pepper-shaper": ["cargoLib": "pepper_shaper", "kotlinName": "pepper-shaper"],
            "perf-net": ["cargoLib": "perf_net", "kotlinName": "perf-net"],
            "quiche-client": ["cargoLib": "quiche_client", "kotlinName": "quiche-client"]
        ]
        def targets = ["aarch64-linux-android", "armv7-linux-androideabi", "x86_64-linux-android", "i686-linux-android"]
        def abiMap = [
            "aarch64-linux-android": "arm64-v8a",
            "armv7-linux-androideabi": "armeabi-v7a",
            "x86_64-linux-android": "x86_64",
            "i686-linux-android": "x86"
        ]
        
        def androidPlatform = "29"
        def ndkPath = android.ndkDirectory?.absolutePath ?: System.getenv("ANDROID_NDK") ?: "${System.getProperty("user.home")}/AppData/Local/Android/Sdk/ndk/28.2.13676358"
        
        // Try to find NDK in common locations
        if (!new File(ndkPath).exists()) {
            def altPaths = [
                "${System.getProperty("user.home")}/AppData/Local/Android/Sdk/ndk/28.2.13676358",
                "${System.getProperty("user.home")}/Android/Sdk/ndk/28.2.13676358",
                "${System.getProperty("user.home")}/Android/Sdk/ndk/25.2.9519653",
                "/c/Users/${System.getProperty("user.name")}/AppData/Local/Android/Sdk/ndk/28.2.13676358"
            ]
            for (altPath in altPaths) {
                if (new File(altPath).exists()) {
                    ndkPath = altPath
                    break
                }
            }
        }
        
        println("ðŸ”¨ Building Rust modules...")
        println("   NDK: ${ndkPath}")
        println("   Platform: ${androidPlatform}")
        
        // Check if we should use WSL for modules that require CMake (perf-net, quiche-client)
        def useWSL = false
        def wslAvailable = false
        if (System.getProperty("os.name").toLowerCase().contains("windows")) {
            try {
                def wslCheck = new ProcessBuilder("wsl", "-d", "Ubuntu", "--", "echo", "WSL_OK")
                    .redirectErrorStream(true)
                    .start()
                def exitCode = wslCheck.waitFor()
                if (exitCode == 0) {
                    wslAvailable = true
                    println("   âœ… WSL (Ubuntu) is available")
                }
            } catch (Exception e) {
                // WSL not available
            }
        }
        
        // Check if cargo-ndk is available (try multiple locations)
        def cargoNdkAvailable = false
        def foundCargoPath = null
        def cargoPaths = []
        
        // Common Rust installation paths
        def userHome = System.getProperty("user.home")
        if (System.getProperty("os.name").toLowerCase().contains("windows")) {
            cargoPaths.add("${userHome}\\.cargo\\bin\\cargo.exe")
            cargoPaths.add("${userHome}\\.cargo\\bin\\cargo")
            // Also try in PATH
            cargoPaths.add("cargo")
        } else {
            cargoPaths.add("${userHome}/.cargo/bin/cargo")
            cargoPaths.add("cargo")
        }
        
        // Try each cargo path
        for (cargoPath in cargoPaths) {
            try {
                def process = new ProcessBuilder(cargoPath, "ndk", "--version")
                    .redirectErrorStream(true)
                    .start()
                def exitCode = process.waitFor()
                if (exitCode == 0) {
                    cargoNdkAvailable = true
                    foundCargoPath = cargoPath
                    println("   âœ… Found cargo-ndk at: ${cargoPath}")
                    break
                }
            } catch (Exception e) {
                // Try next path
            }
        }
        
        // Check WSL for cargo-ndk if Windows and not found locally
        if (!cargoNdkAvailable && wslAvailable) {
            try {
                def wslCargoCheck = new ProcessBuilder("wsl", "-d", "Ubuntu", "--", "bash", "-c", "command -v cargo-ndk")
                    .redirectErrorStream(true)
                    .start()
                def exitCode = wslCargoCheck.waitFor()
                if (exitCode == 0) {
                    cargoNdkAvailable = true
                    useWSL = true
                    println("   âœ… Found cargo-ndk in WSL")
                }
            } catch (Exception e) {
                // WSL cargo-ndk not available
            }
        }
        
        if (!cargoNdkAvailable) {
            def setupScript = System.getProperty("os.name").toLowerCase().contains("windows") 
                ? "scripts\\setup-wsl.ps1" 
                : "scripts/setup-rust.sh"
            throw new RuntimeException(
                "âŒ cargo-ndk is REQUIRED to build Rust modules!\n" +
                "\n" +
                "   Rust MUST be used for this project. Please install Rust and cargo-ndk:\n" +
                "\n" +
                "   Quick setup:\n" +
                "   - Windows:  .\\scripts\\setup-wsl.ps1 (recommended for perf-net/quiche-client)\n" +
                "   - Windows:  .\\scripts\\setup-rust.ps1 (for simple modules only)\n" +
                "   - Linux/Mac: ./scripts/setup-rust.sh\n" +
                "\n" +
                "   Manual setup:\n" +
                "   1. Install Rust: https://rustup.rs/\n" +
                "   2. Install cargo-ndk: cargo install cargo-ndk\n" +
                "   3. Add Android targets:\n" +
                "      rustup target add aarch64-linux-android\n" +
                "      rustup target add armv7-linux-androideabi\n" +
                "      rustup target add x86_64-linux-android\n" +
                "      rustup target add i686-linux-android\n" +
                "\n" +
                "   After installation, restart your terminal and try building again."
            )
        }
        
        // Use the found cargo path for building
        def cargoCommand = foundCargoPath ?: "cargo"
        
        // Helper function to convert Windows path to WSL path
        def toWSLPath = { String winPath ->
            if (!System.getProperty("os.name").toLowerCase().contains("windows")) {
                return winPath
            }
            // Convert C:\Users\... to /mnt/c/Users/...
            def wslPath = winPath.replaceAll("^([A-Z]):", "/mnt/\$1").replace("\\", "/").toLowerCase()
            return wslPath
        }
        
        rustModules.each { moduleName, config ->
            println("   Building ${moduleName}...")
            def moduleDir = file("src/main/jni/${moduleName}")
            def cargoLibName = config["cargoLib"]
            def kotlinLibName = config["kotlinName"]
            
            if (!moduleDir.exists()) {
                println("   âš ï¸  Module ${moduleName} not found, skipping")
                return
            }
            
            // Determine if this module needs WSL (modules with CMake dependencies)
            def needsWSL = (moduleName == "perf-net" || moduleName == "quiche-client") && useWSL && wslAvailable
            
            targets.each { target ->
                def abi = abiMap[target]
                def sourceLib = file("${moduleDir}/target/${target}/release/lib${cargoLibName}.so")
                def destDir = file("src/main/jniLibs/${abi}")
                def destLib = file("${destDir}/lib${kotlinLibName}.so")
                
                // Check if library already exists in jniLibs (from CI artifacts)
                if (destLib.exists()) {
                    println("   âœ… ${moduleName} (${abi}): lib${kotlinLibName}.so already exists, skipping build")
                    return
                }
                
                // Build Rust library if not found
                println("   ðŸ”¨ Building ${moduleName} for ${target}...")
                if (needsWSL) {
                    println("   ðŸ§ Using WSL for ${moduleName} (CMake dependencies)")
                }
                
                def processBuilder
                if (needsWSL) {
                    // Build in WSL
                    def wslModuleDir = toWSLPath(moduleDir.absolutePath)
                    def wslNdkPath = toWSLPath(ndkPath)
                    
                    // Build command to run in WSL
                    def buildCmd = """
                        export ANDROID_NDK=${wslNdkPath} &&
                        export ANDROID_NDK_HOME=${wslNdkPath} &&
                        export NDK_HOME=${wslNdkPath} &&
                        export ANDROID_PLATFORM=${androidPlatform} &&
                        export ANDROID_ABI=${abi} &&
                        export CMAKE_TOOLCHAIN_FILE=${wslNdkPath}/build/cmake/android.toolchain.cmake &&
                        export CMAKE_GENERATOR=Ninja &&
                        cd ${wslModuleDir} &&
                        cargo ndk --target ${target} --platform ${androidPlatform} build --release
                    """.trim().replaceAll("\n", " ").replaceAll(" +", " ")
                    
                    processBuilder = new ProcessBuilder("wsl", "-d", "Ubuntu", "--", "bash", "-c", buildCmd)
                        .redirectErrorStream(true)
                } else {
                    // Build natively (Windows or Linux)
                    processBuilder = new ProcessBuilder(cargoCommand, "ndk",
                        "--target", target,
                        "--platform", androidPlatform,
                        "build",
                        "--release")
                        .directory(moduleDir)
                        .redirectErrorStream(true)
                }
                
                // Set up environment variables for cmake/NDK (only for native builds)
                if (!needsWSL) {
                    def env = processBuilder.environment()
                env.put("ANDROID_NDK", ndkPath.toString())
                env.put("ANDROID_NDK_HOME", ndkPath.toString())
                env.put("NDK_HOME", ndkPath.toString())
                env.put("ANDROID_PLATFORM", androidPlatform.toString())
                
                // Map Rust target to Android ABI
                def androidAbi = abiMap[target]
                env.put("ANDROID_ABI", androidAbi.toString())
                
                // Add ninja to PATH if it exists in user's bin directory
                def userBin = new File(System.getProperty("user.home"), "bin").absolutePath
                def userBinFile = new File(userBin)
                if (userBinFile.exists() && new File(userBinFile, "ninja.exe").exists()) {
                    def currentPath = env.get("PATH")
                    def pathStr = currentPath ? currentPath.toString() : ""
                    if (!pathStr.contains(userBin)) {
                        env.put("PATH", userBin + ";" + pathStr)
                    }
                }
                
                // Set CMAKE_TOOLCHAIN_FILE if NDK exists
                def ndkFile = new File(ndkPath)
                if (ndkFile.exists()) {
                    def toolchainFile = new File(ndkFile, "build/cmake/android.toolchain.cmake")
                    if (toolchainFile.exists()) {
                        env.put("CMAKE_TOOLCHAIN_FILE", toolchainFile.absolutePath.toString())
                        
                        // Set Android-specific cmake variables
                        env.put("ANDROID_ABI", androidAbi.toString())
                        env.put("ANDROID_PLATFORM", "android-" + androidPlatform.toString())
                        env.put("ANDROID_NDK", ndkPath.toString())
                        
                        // aws-lc-sys uses cmake crate which doesn't read CMAKE_ARGS env var
                        // Instead, we need to set ANDROID_ABI via cmake's build script mechanism
                        // The cmake crate reads AWS_LC_SYS_CMAKE_* environment variables
                        env.put("AWS_LC_SYS_CMAKE_ANDROID_ABI", androidAbi.toString())
                        env.put("AWS_LC_SYS_CMAKE_ANDROID_PLATFORM", "android-" + androidPlatform.toString())
                        
                        // Also try setting via target-specific variables
                        def targetEnvVar = target.replace("-", "_")
                        env.put("AWS_LC_SYS_CMAKE_ANDROID_ABI_" + targetEnvVar, androidAbi.toString())
                        env.put("AWS_LC_SYS_CMAKE_ANDROID_PLATFORM_" + targetEnvVar, "android-" + androidPlatform.toString())
                        
                        // Try to find ninja in common locations
                        def userHomePath = System.getProperty("user.home")
                        def ninjaPaths = [
                            new File(userHomePath, "bin/ninja.exe").absolutePath,
                            "ninja.exe",
                            "ninja"
                        ]
                        def foundNinja = null
                        for (ninjaPath in ninjaPaths) {
                            def ninjaFile = new File(ninjaPath)
                            if (ninjaFile.exists() || ninjaPath == "ninja" || ninjaPath == "ninja.exe") {
                                // Check if it's in PATH
                                try {
                                    def testProcess = new ProcessBuilder(ninjaPath, "--version")
                                        .redirectErrorStream(true)
                                        .start()
                                    def exitCode = testProcess.waitFor()
                                    if (exitCode == 0) {
                                        foundNinja = ninjaPath
                                        break
                                    }
                                } catch (Exception e) {
                                    // Try next path
                                }
                            }
                        }
                        
                        if (foundNinja != null) {
                            env.put("CMAKE_GENERATOR", "Ninja")
                            // Always set CMAKE_MAKE_PROGRAM to full path for reliability
                            def ninjaPath = foundNinja.toString()
                            if (ninjaPath != "ninja" && ninjaPath != "ninja.exe") {
                                env.put("CMAKE_MAKE_PROGRAM", ninjaPath)
                            } else {
                                // If found in PATH, use full path from user bin
                                def userBinNinja = new File(System.getProperty("user.home"), "bin/ninja.exe")
                                if (userBinNinja.exists()) {
                                    env.put("CMAKE_MAKE_PROGRAM", userBinNinja.absolutePath.toString())
                                }
                            }
                            println("   ðŸ“ Using Ninja: ${foundNinja}")
                            if (env.get("CMAKE_MAKE_PROGRAM")) {
                                println("   ðŸ“ CMAKE_MAKE_PROGRAM: ${env.get("CMAKE_MAKE_PROGRAM")}")
                            }
                        } else {
                            // Fallback: Use Unix Makefiles (requires make/gcc in PATH)
                            env.put("CMAKE_GENERATOR", "Unix Makefiles")
                            println("   âš ï¸  Ninja not found, using Unix Makefiles generator")
                        }
                        
                        // Also set target-specific variables
                        def targetEnv = target.replace("-", "_")
                        env.put("CMAKE_TOOLCHAIN_FILE_" + targetEnv, toolchainFile.absolutePath.toString())
                        def generator = env.get("CMAKE_GENERATOR")
                        env.put("CMAKE_GENERATOR_" + targetEnv, generator ? generator.toString() : "Ninja")
                        println("   ðŸ“ Using CMAKE_TOOLCHAIN_FILE: ${toolchainFile.absolutePath}")
                    }
                }
                }
                
                def process = processBuilder.start()
                
                // Read output in real-time
                def reader = new BufferedReader(new InputStreamReader(process.inputStream))
                def line
                def output = new StringBuilder()
                while ((line = reader.readLine()) != null) {
                    println("   ${line}")
                    output.append(line).append("\n")
                }
                
                def exitCode = process.waitFor()
                if (exitCode != 0) {
                    throw new RuntimeException(
                        "âŒ Failed to build ${moduleName} for ${target}!\n" +
                        "   Exit code: ${exitCode}\n" +
                        "   Last output lines:\n" +
                        output.toString().split("\n").takeRight(10).join("\n")
                    )
                }
                
                // Verify library was built
                if (!sourceLib.exists()) {
                    throw new RuntimeException(
                        "âŒ Failed to build ${moduleName} for ${target}!\n" +
                        "   Expected library at: ${sourceLib.absolutePath}\n" +
                        "   Check Cargo build output for errors."
                    )
                }
                
                // Copy library to jniLibs with Kotlin-expected name
                destDir.mkdirs()
                copy {
                    from sourceLib
                    into destDir
                    rename { "lib${kotlinLibName}.so" }
                }
                println("   âœ… ${moduleName} (${abi}): lib${kotlinLibName}.so")
            }
        }
        
        println("âœ… Rust modules build complete!")
    }
}

// Always build Rust modules before NDK build (if available)
tasks.matching { task ->
    task.name.startsWith("externalNativeBuild") && 
    (task.name.contains("Debug") || task.name.contains("Release"))
}.configureEach { task ->
    task.dependsOn("checkBoringSSL", "copyQuicheLibraries", "buildRustModules")
}

// Ensure Rust modules are built before any build task (if available)
tasks.matching { task ->
    (task.name.contains("assemble") || task.name.contains("bundle")) &&
    (task.name.contains("Debug") || task.name.contains("Release"))
}.configureEach { task ->
    task.dependsOn("buildRustModules")
}

// buildRustModules is REQUIRED - build will fail if Rust modules can't be built

// Run debug files check before debug builds
tasks.matching { task ->
    task.name.contains("Debug") && 
    (task.name.contains("assemble") || task.name.contains("bundle"))
}.configureEach { task ->
    task.dependsOn("checkDebugFiles")
}

dependencies {
    implementation "io.grpc:grpc-okhttp:1.75.0"
    implementation "io.grpc:grpc-protobuf:1.75.0"
    implementation "io.grpc:grpc-stub:1.75.0"
    implementation "io.grpc:grpc-kotlin-stub:1.5.0"

    implementation 'com.google.android.material:material:1.13.0'
    implementation 'com.google.code.gson:gson:2.13.1'
    implementation 'androidx.preference:preference-ktx:1.2.1'
    implementation 'androidx.core:core-ktx:1.17.0'
    implementation 'androidx.appcompat:appcompat:1.7.1'
    
    // Firebase
    implementation platform('com.google.firebase:firebase-bom:33.8.0')
    implementation 'com.google.firebase:firebase-crashlytics-ktx'
    implementation 'com.google.firebase:firebase-analytics-ktx'
    
    // Dependency Injection
    implementation "javax.inject:javax.inject:1"

    // Coroutines
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.10.2"

    implementation platform('androidx.compose:compose-bom:2025.10.01')
    implementation 'androidx.compose.ui:ui'
    implementation 'androidx.compose.ui:ui-graphics'
    implementation 'androidx.compose.material3:material3'
    implementation 'androidx.compose.material:material-icons-extended'
    implementation 'androidx.compose.ui:ui-tooling-preview-android'
    implementation 'androidx.activity:activity-compose'
    implementation 'androidx.compose.runtime:runtime-livedata'
    implementation 'androidx.navigation:navigation-compose-android:2.9.3'

    implementation 'com.github.nanihadesuka:LazyColumnScrollbar:2.2.0'
    implementation 'sh.calvin.reorderable:reorderable:2.5.1'
    implementation "com.squareup.okhttp3:okhttp:4.12.0"

    // Room Database
    def room_version = "2.7.2"
    implementation "androidx.room:room-runtime:$room_version"
    implementation "androidx.room:room-ktx:$room_version"
    ksp "androidx.room:room-compiler:$room_version"

    // WorkManager
    implementation "androidx.work:work-runtime-ktx:2.10.3"
    
    // Timber for logging
    implementation "com.jakewharton.timber:timber:5.0.1"

    // Vico Charts
    implementation "com.patrykandpatrick.vico:compose:2.0.0-alpha.28"
    implementation "com.patrykandpatrick.vico:compose-m3:2.0.0-alpha.28"
    implementation "com.patrykandpatrick.vico:core:2.0.0-alpha.28"

    // Glance for Widgets
    implementation "androidx.glance:glance:1.1.1"
    implementation "androidx.glance:glance-appwidget:1.1.1"
    implementation "androidx.glance:glance-material3:1.1.1"

    // ViewModel
    implementation "androidx.lifecycle:lifecycle-viewmodel-compose:2.9.2"
    implementation "androidx.lifecycle:lifecycle-runtime-compose:2.9.2"

    // Testing dependencies
    // Note: JUnit 4 is used for Android compatibility. JUnit 5 (Jupiter) requires additional setup.
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'io.mockk:mockk:1.14.3'
    // Updated to match coroutines version for better compatibility
    testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.10.2'
    testImplementation 'androidx.arch.core:core-testing:2.2.0'
    testImplementation 'com.google.truth:truth:1.1.5'
    testImplementation 'org.json:json:20240303'

    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
    androidTestImplementation 'androidx.test:core:1.5.0'
    androidTestImplementation platform('androidx.compose:compose-bom:2025.08.00')
    androidTestImplementation 'androidx.compose.ui:ui-test-junit4'
    androidTestImplementation 'io.mockk:mockk-android:1.14.3'

    debugImplementation 'androidx.compose.ui:ui-tooling'
    debugImplementation 'androidx.compose.ui:ui-test-manifest'
}

// Configure test task to support filtering
afterEvaluate {
    tasks.withType(Test).configureEach {
        // Support test filtering via project property
        if (project.hasProperty('testFilter')) {
            filter {
                includeTestsMatching project.property('testFilter')
            }
        }
    }
    
    // Make Google Services tasks optional if config file doesn't exist
    def hasGoogleServices = file('src/debug/google-services.json').exists() ||
                           file('src/google-services.json').exists() ||
                           file('google-services.json').exists()
    
    if (!hasGoogleServices) {
        println "âš ï¸  google-services.json not found - disabling Google Services tasks"
        tasks.matching { it.name.contains('GoogleServices') || it.name.contains('Crashlytics') }.configureEach { task ->
            enabled = false
            doFirst {
                println "Skipping ${task.name} - google-services.json not found"
            }
        }
    }
}