plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
    id 'org.jetbrains.kotlin.plugin.compose'
    id 'com.google.protobuf' version '0.9.4'
    id 'com.google.devtools.ksp'
    id 'com.google.gms.google-services'
    id 'com.google.firebase.crashlytics'
}

// Create dummy google-services.json if it doesn't exist (for CI builds)
def googleServicesFile = file('google-services.json')
if (!googleServicesFile.exists()) {
    def debugFile = file('src/debug/google-services.json')
    def mainFile = file('src/google-services.json')
    
    if (!debugFile.exists() && !mainFile.exists()) {
        println "âš ï¸  google-services.json not found - creating dummy file for build"
        googleServicesFile.parentFile.mkdirs()
        googleServicesFile.text = '''{
  "project_info": {
    "project_number": "000000000000",
    "project_id": "dummy-project",
    "storage_bucket": "dummy-project.appspot.com"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:000000000000:android:0000000000000000000000",
        "android_client_info": {
          "package_name": "com.simplexray.an"
        }
      },
      "oauth_client": [],
      "api_key": [
        {
          "current_key": "AIzaSyDummy-Key-For-CI-Build-Only"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": []
        }
      }
    }
  ],
  "configuration_version": "1"
}'''
    }
}

protobuf {
    protoc {
        artifact = 'com.google.protobuf:protoc:3.25.1'
    }
    plugins {
        grpc {
            artifact = 'io.grpc:protoc-gen-grpc-java:1.75.0'
        }
        grpc_kotlin {
            artifact = 'io.grpc:protoc-gen-grpc-kotlin:1.5.0:jdk8'
        }
        grpckt {
            artifact = 'io.grpc:protoc-gen-grpc-kotlin:1.5.0:jdk8@jar'
        }
    }
    generateProtoTasks {
        all().each { task ->
            task.builtins {
                java {}
            }
            task.plugins {
                grpc {}
                grpckt {}
            }
        }
    }
}

def versionProps = new Properties()
file("$rootDir/version.properties").withInputStream { versionProps.load(it) }

android {
    namespace "com.simplexray.an"
    compileSdk = 36

    defaultConfig {
        applicationId "com.simplexray.an"
        versionCode versionProps.APP_VERSION_CODE.toInteger()
        versionName versionProps.APP_VERSION_NAME

        // Runtime SSL mode configuration
        def sslMode = System.getenv("SXR_SSL_MODE") ?: "boringssl"
        resValue "string", "sxr_ssl_mode", sslMode
        buildConfigField "String", "SXR_SSL_MODE", "\"${sslMode}\""

        // Always use BoringSSL (OpenSSL removed)
        buildConfigField "boolean", "USE_BORINGSSL", "true"
        println "ðŸ”’ Building with BoringSSL"

        // Experimental features (debug only)
        def isRelease = gradle.startParameter.taskNames.any { it.contains("Release") }
        buildConfigField "boolean", "EXPERIMENTAL_ENABLED", "${!isRelease}"

        targetSdk = 35
        minSdk = 29

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"

        // BuildConfig fields for update mechanism
        buildConfigField "String", "REPOSITORY_URL", "\"https://github.com/halibiram/SimpleXray\""
        buildConfigField "String[]", "SUPPORTED_ABIS", "new String[]{\"arm64-v8a\", \"x86_64\"}"
        buildConfigField "boolean", "FEAT_STREAMING_PANEL", "false" // Feature flag for streaming panel UI
        buildConfigField "boolean", "FEAT_GAME_PANEL", "false" // Feature flag for game optimization panel UI
        buildConfigField "boolean", "FEAT_PERF_PANEL", "false" // Feature flag for performance diagnostics panel
        buildConfigField "boolean", "FEAT_HYPER_UI", "false" // Feature flag for hyper UI performance components

        // Crypto library build status (BoringSSL only)
        def boringsslAvailable = file("../external/boringssl/lib/arm64-v8a/libcrypto.a").exists()
        buildConfigField "boolean", "BORINGSSL_AVAILABLE_AT_BUILD", "${boringsslAvailable}"
        buildConfigField "boolean", "OPENSSL_AVAILABLE_AT_BUILD", "false"

        // NDK build configuration - Pass correct package and class names to JNI
        externalNativeBuild {
            ndkBuild {
                // CRITICAL: Pass correct package and class names to JNI for FindClass
                arguments "PKGNAME=com/simplexray/an/service", "CLSNAME=TProxyService"
                cFlags "-DPKGNAME=com/simplexray/an/service", "-DCLSNAME=TProxyService"
            }
        }
    }

    signingConfigs {
        release {
            enableV1Signing = true
            enableV2Signing = true
            enableV3Signing = true
            // SEC: V4 signing disabled - may affect Android 11+ compatibility
        // TODO: Enable V4 signing for Android 11+ devices
        // UPGRADE-RISK: V4 signing required for Android 11+ - may cause installation issues
            enableV4Signing = false
        }
    }

    buildTypes {
        release {
            minifyEnabled true
            shrinkResources = true
            signingConfig = signingConfigs.release
            proguardFiles(
                    getDefaultProguardFile('proguard-android-optimize.txt'),
                    'proguard-rules.pro'
            )
        }
        debug {
            minifyEnabled false
            signingConfig = signingConfigs.release
            debuggable true
        }
    }

    // COMPAT: JavaVersion.VERSION_21 is required for Android SDK 35
    // Verified: Java 21 is fully compatible with Android SDK 35 and required for modern Android development
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_21
        targetCompatibility JavaVersion.VERSION_21
    }

    // SEC: Signing config loaded from file - ensure store.properties is not committed
    def propsFile = rootProject.file('store.properties')
    def configName = 'release'

    if (propsFile.exists() && signingConfigs.hasProperty(configName)) {
        def props = new Properties()
        props.load(new FileInputStream(propsFile))
        if (props != null && props.containsKey('storeFile')) {
            signingConfigs.named(configName).configure { signingConfig ->
                // Validate storeFile path to prevent loading wrong file
                def storeFilePath = props['storeFile']
                if (storeFilePath == null || storeFilePath.isEmpty()) {
                    throw new GradleException("storeFile path is empty in store.properties")
                }
                def storeFile = rootProject.file(storeFilePath)
                if (!storeFile.exists()) {
                    throw new GradleException("Store file not found: ${storeFile.absolutePath}")
                }
                if (!storeFile.isFile()) {
                    throw new GradleException("Store file path is not a file: ${storeFile.absolutePath}")
                }
                signingConfig.storeFile = storeFile
                
                // SEC: Passwords stored in plain text - prefer environment variables
                // TODO: Consider using Gradle encrypted properties or keychain
                // Use environment variables if available, fallback to properties file
                signingConfig.storePassword = System.getenv('KEYSTORE_PASSWORD') ?: props['storePassword']
                signingConfig.keyAlias = props['keyAlias']
                signingConfig.keyPassword = System.getenv('KEY_PASSWORD') ?: props['keyPassword']
                
                if (signingConfig.storePassword == null || signingConfig.storePassword.isEmpty()) {
                    throw new GradleException("Store password is required but not provided")
                }
                if (signingConfig.keyPassword == null || signingConfig.keyPassword.isEmpty()) {
                    throw new GradleException("Key password is required but not provided")
                }
            }
        }
    }

    externalNativeBuild {
        ndkBuild {
            path "src/main/jni/Android.mk"
        }
    }

    lint {
        // Enable lint checks for release builds but don't abort on errors
        // This allows builds to complete while still reporting issues
        checkReleaseBuilds = true
        // Continue the build even when errors are found (warnings only)
        // BUG: Lint errors don't block build - may ship code with issues
        // TODO: Consider enabling abortOnError=true for release builds
        // Note: abortOnError=false allows builds to complete but issues should be reviewed
        // TEST-GAP: Lint errors not caught in CI - may ship broken code
        abortOnError = false
        // Treat warnings as errors only in strict mode (not enabled by default)
        warningsAsErrors = false
    }

    // Note: extractNativeLibs is no longer supported in AGP 8.0+
    // Native libraries are extracted by default for APKs in AGP 8.0+
    
    // Legacy packaging options (kept for compatibility)
    packagingOptions {
        jniLibs {
            useLegacyPackaging = true
        }
    }

    dependenciesInfo {
        // Disables dependency metadata when building APKs.
        includeInApk = false
        // Disables dependency metadata when building Android App Bundles.
        includeInBundle = false
    }
    ndkVersion = versionProps.NDK_VERSION

    splits {
        abi {
            enable = true
            reset()
            include "arm64-v8a"  // Only build arm64-v8a for faster builds
            universalApk false
        }
    }

    applicationVariants.configureEach { variant ->
        variant.outputs.each { output ->
            def abiFilter = output.getFilter("ABI")
            if (abiFilter != null) {
                output.outputFileName = "simplexray-${abiFilter}.apk"
            } else {
                output.outputFileName = "simplexray-universal.apk"
            }
        }
    }

    buildFeatures {
        compose true
        buildConfig true
    }

    // COMPAT: jvmToolchain(21) requires JDK 21 - required for building this project
    // Note: JDK 21 is required for Android SDK 35 compatibility. Ensure JDK 21 is installed before building.
    kotlin {
        jvmToolchain(21)
    }

    sourceSets {
        main {
            java {
                srcDirs 'src/main/java', 'build/generated/source/proto/main/java'
            }
            kotlin {
                srcDirs 'src/main/kotlin', 'build/generated/source/proto/main/grpckt', 'build/generated/ksp/debug/kotlin', 'build/generated/ksp/release/kotlin'
            }
            // Ensure jniLibs and assets are included for debug builds
            jniLibs {
                srcDirs 'src/main/jniLibs'
            }
            assets {
                srcDirs 'src/main/assets'
            }
        }
        debug {
            // Debug build uses local files from jniLibs and assets
            jniLibs {
                srcDirs 'src/main/jniLibs'
            }
            assets {
                srcDirs 'src/main/assets'
            }
        }
    }
}

// Pre-build check for local debug files
tasks.register("checkDebugFiles") {
    doLast {
        def isDebugBuild = gradle.startParameter.taskNames.any { 
            it.contains("Debug") || it.contains("debug") 
        }
        
        if (isDebugBuild) {
            println("ðŸ” Checking local debug files...")
            
            // Check jniLibs
            def jniLibsDir = file("src/main/jniLibs")
            def hasJniLibs = jniLibsDir.exists() && jniLibsDir.listFiles()?.length > 0
            
            if (hasJniLibs) {
                println("âœ… Local jniLibs found: ${jniLibsDir.absolutePath}")
                jniLibsDir.listFiles()?.each { abiDir ->
                    if (abiDir.isDirectory()) {
                        def xrayLib = new File(abiDir, "libxray.so")
                        def hysteria2Lib = new File(abiDir, "libhysteria2.so")
                        if (xrayLib.exists()) {
                            println("   âœ… libxray.so found for ${abiDir.name} (${xrayLib.length()} bytes)")
                        }
                        if (hysteria2Lib.exists()) {
                            println("   âœ… libhysteria2.so found for ${abiDir.name} (${hysteria2Lib.length()} bytes)")
                        }
                    }
                }
            } else {
                println("âš ï¸  WARNING: Local jniLibs not found!")
                println("   Run: ./scripts/download-debug-files.ps1 (Windows) or ./scripts/download-debug-files.sh (Linux/Mac)")
                println("   Build will continue but may use fallback libraries.")
            }
            
            // Check assets
            def assetsDir = file("src/main/assets")
            def geoipFile = new File(assetsDir, "geoip.dat")
            def geositeFile = new File(assetsDir, "geosite.dat")
            
            if (geoipFile.exists() && geositeFile.exists()) {
                println("âœ… Local assets found:")
                println("   âœ… geoip.dat (${geoipFile.length()} bytes)")
                println("   âœ… geosite.dat (${geositeFile.length()} bytes)")
            } else {
                println("âš ï¸  WARNING: Local assets not found!")
                if (!geoipFile.exists()) {
                    println("   Missing: geoip.dat")
                }
                if (!geositeFile.exists()) {
                    println("   Missing: geosite.dat")
                }
                println("   Run: ./scripts/download-debug-files.ps1 (Windows) or ./scripts/download-debug-files.sh (Linux/Mac)")
            }
        }
    }
}

// Pre-build check for BoringSSL
tasks.register("checkBoringSSL") {
    doLast {
        def boringsslDir = file("../external/boringssl")
        def boringsslLibCryptoArm64 = file("../external/boringssl/lib/arm64-v8a/libcrypto.a")
        def boringsslLibSslArm64 = file("../external/boringssl/lib/arm64-v8a/libssl.a")
        
        def hasBoringSSL = boringsslLibCryptoArm64.exists() && 
                           boringsslLibSslArm64.exists()
        
        if (!hasBoringSSL) {
            println("âš ï¸  WARNING: BoringSSL libraries not found!")
            println("   BoringSSL directory: ${boringsslDir.absolutePath}")
            println("   Expected files:")
            println("     - ${boringsslLibCryptoArm64.absolutePath}")
            println("     - ${boringsslLibSslArm64.absolutePath}")
            println("")
            println("   To build BoringSSL:")
            println("   1. Run: ./external/boringssl/build_all_abis.py")
            println("   2. Or follow instructions in external/boringssl/README.md")
            println("")
            println("   Note: Build will continue but crypto features may not work.")
        } else {
            println("âœ… BoringSSL found: ${boringsslDir.absolutePath}")
        }
    }
}

// Copy QUICHE libraries from artifacts to quiche-client/libs/
tasks.register("copyQuicheLibraries") {
    doLast {
        def quicheClientLibsDir = file("src/main/jni/quiche-client/libs")
        def artifactsDir = file("../artifacts")
        
        def abis = ["arm64-v8a", "x86_64"]
        def copiedCount = 0
        
        abis.each { abi ->
            def sourceLib = file("${artifactsDir}/quiche-${abi}/libquiche.a")
            def targetDir = file("${quicheClientLibsDir}/${abi}")
            def targetLib = file("${targetDir}/libquiche.a")
            
            if (sourceLib.exists()) {
                targetDir.mkdirs()
                copy {
                    from sourceLib
                    into targetDir
                }
                println("âœ… Copied ${sourceLib.name} to ${targetDir.absolutePath}")
                copiedCount++
            } else {
                println("âš ï¸  QUICHE library not found at ${sourceLib.absolutePath}")
                println("   Expected location: artifacts/quiche-${abi}/libquiche.a")
            }
        }
        
        if (copiedCount > 0) {
            println("âœ… QUICHE libraries copied: ${copiedCount}/${abis.size()} ABIs")
        } else {
            println("âš ï¸  WARNING: No QUICHE libraries found in artifacts directory")
            println("   QUICHE native build will be skipped")
            println("   To build QUICHE:")
            println("   1. Run: cd app/src/main/jni/quiche-client && ./build-quiche-android.sh")
            println("   2. Or download from CI artifacts")
        }
    }
}

// Build Rust native modules
tasks.register("buildRustModules") {
    doLast {
        def rustModules = ["xray-signal-handler", "pepper-shaper", "perf-net", "quiche-client"]
        def targets = ["aarch64-linux-android", "armv7-linux-androideabi", "x86_64-linux-android", "i686-linux-android"]
        def abiMap = [
            "aarch64-linux-android": "arm64-v8a",
            "armv7-linux-androideabi": "armeabi-v7a",
            "x86_64-linux-android": "x86_64",
            "i686-linux-android": "x86"
        ]
        
        def androidPlatform = "29"
        def ndkPath = android.ndkDirectory?.absolutePath ?: System.getenv("ANDROID_NDK") ?: "${System.getProperty("user.home")}/Android/Sdk/ndk/25.2.9519653"
        
        println("ðŸ”¨ Building Rust modules...")
        println("   NDK: ${ndkPath}")
        println("   Platform: ${androidPlatform}")
        
        rustModules.each { module ->
            println("   Building ${module}...")
            targets.each { target ->
                def abi = abiMap[target]
                def moduleDir = file("src/main/jni/${module}")
                def libName = module.replace("-", "_")
                
                if (!moduleDir.exists()) {
                    println("   âš ï¸  Module ${module} not found, skipping")
                    return
                }
                
                // Build Rust library
                exec {
                    workingDir moduleDir
                    commandLine "cargo", "ndk",
                        "--target", target,
                        "--platform", androidPlatform,
                        "build",
                        "--release"
                }
                
                // Copy library to jniLibs
                def sourceLib = file("${moduleDir}/target/${target}/release/lib${libName}.so")
                def destDir = file("src/main/jniLibs/${abi}")
                def destLib = file("${destDir}/lib${libName}.so")
                
                if (sourceLib.exists()) {
                    destDir.mkdirs()
                    copy {
                        from sourceLib
                        into destDir
                    }
                    println("   âœ… ${module} (${abi}): ${destLib.absolutePath}")
                } else {
                    println("   âš ï¸  ${module} (${abi}): Library not found at ${sourceLib.absolutePath}")
                }
            }
        }
        
        println("âœ… Rust modules build complete!")
    }
}

// Run checks before build
tasks.matching { task ->
    task.name.startsWith("externalNativeBuild") && 
    (task.name.contains("Debug") || task.name.contains("Release"))
}.configureEach { task ->
    task.dependsOn("checkBoringSSL", "copyQuicheLibraries", "buildRustModules")
}

// Run debug files check before debug builds
tasks.matching { task ->
    task.name.contains("Debug") && 
    (task.name.contains("assemble") || task.name.contains("bundle"))
}.configureEach { task ->
    task.dependsOn("checkDebugFiles")
}

dependencies {
    implementation "io.grpc:grpc-okhttp:1.75.0"
    implementation "io.grpc:grpc-protobuf:1.75.0"
    implementation "io.grpc:grpc-stub:1.75.0"
    implementation "io.grpc:grpc-kotlin-stub:1.5.0"

    implementation 'com.google.android.material:material:1.13.0'
    implementation 'com.google.code.gson:gson:2.13.1'
    implementation 'androidx.preference:preference-ktx:1.2.1'
    implementation 'androidx.core:core-ktx:1.17.0'
    implementation 'androidx.appcompat:appcompat:1.7.1'
    
    // Firebase
    implementation platform('com.google.firebase:firebase-bom:33.8.0')
    implementation 'com.google.firebase:firebase-crashlytics-ktx'
    implementation 'com.google.firebase:firebase-analytics-ktx'
    
    // Dependency Injection
    implementation "javax.inject:javax.inject:1"

    // Coroutines
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.10.2"

    implementation platform('androidx.compose:compose-bom:2025.10.01')
    implementation 'androidx.compose.ui:ui'
    implementation 'androidx.compose.ui:ui-graphics'
    implementation 'androidx.compose.material3:material3'
    implementation 'androidx.compose.material:material-icons-extended'
    implementation 'androidx.compose.ui:ui-tooling-preview-android'
    implementation 'androidx.activity:activity-compose'
    implementation 'androidx.compose.runtime:runtime-livedata'
    implementation 'androidx.navigation:navigation-compose-android:2.9.3'

    implementation 'com.github.nanihadesuka:LazyColumnScrollbar:2.2.0'
    implementation 'sh.calvin.reorderable:reorderable:2.5.1'
    implementation "com.squareup.okhttp3:okhttp:4.12.0"

    // Room Database
    def room_version = "2.7.2"
    implementation "androidx.room:room-runtime:$room_version"
    implementation "androidx.room:room-ktx:$room_version"
    ksp "androidx.room:room-compiler:$room_version"

    // WorkManager
    implementation "androidx.work:work-runtime-ktx:2.10.3"
    
    // Timber for logging
    implementation "com.jakewharton.timber:timber:5.0.1"

    // Vico Charts
    implementation "com.patrykandpatrick.vico:compose:2.0.0-alpha.28"
    implementation "com.patrykandpatrick.vico:compose-m3:2.0.0-alpha.28"
    implementation "com.patrykandpatrick.vico:core:2.0.0-alpha.28"

    // Glance for Widgets
    implementation "androidx.glance:glance:1.1.1"
    implementation "androidx.glance:glance-appwidget:1.1.1"
    implementation "androidx.glance:glance-material3:1.1.1"

    // ViewModel
    implementation "androidx.lifecycle:lifecycle-viewmodel-compose:2.9.2"
    implementation "androidx.lifecycle:lifecycle-runtime-compose:2.9.2"

    // Testing dependencies
    // Note: JUnit 4 is used for Android compatibility. JUnit 5 (Jupiter) requires additional setup.
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'io.mockk:mockk:1.14.3'
    // Updated to match coroutines version for better compatibility
    testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.10.2'
    testImplementation 'androidx.arch.core:core-testing:2.2.0'
    testImplementation 'com.google.truth:truth:1.1.5'
    testImplementation 'org.json:json:20240303'

    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
    androidTestImplementation 'androidx.test:core:1.5.0'
    androidTestImplementation platform('androidx.compose:compose-bom:2025.08.00')
    androidTestImplementation 'androidx.compose.ui:ui-test-junit4'
    androidTestImplementation 'io.mockk:mockk-android:1.14.3'

    debugImplementation 'androidx.compose.ui:ui-tooling'
    debugImplementation 'androidx.compose.ui:ui-test-manifest'
}

// Configure test task to support filtering
afterEvaluate {
    tasks.withType(Test).configureEach {
        // Support test filtering via project property
        if (project.hasProperty('testFilter')) {
            filter {
                includeTestsMatching project.property('testFilter')
            }
        }
    }
    
    // Make Google Services tasks optional if config file doesn't exist
    def hasGoogleServices = file('src/debug/google-services.json').exists() ||
                           file('src/google-services.json').exists() ||
                           file('google-services.json').exists()
    
    if (!hasGoogleServices) {
        println "âš ï¸  google-services.json not found - disabling Google Services tasks"
        tasks.matching { it.name.contains('GoogleServices') || it.name.contains('Crashlytics') }.configureEach { task ->
            enabled = false
            doFirst {
                println "Skipping ${task.name} - google-services.json not found"
            }
        }
    }
}