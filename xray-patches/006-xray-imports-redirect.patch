diff --git a/common/crypto/crypto_cgo.go b/common/crypto/crypto_cgo.go
new file mode 100644
index 0000000..70ea6a1
--- /dev/null
+++ b/common/crypto/crypto_cgo.go
@@ -0,0 +1,41 @@
+//go:build cgo
+// +build cgo
+
+package crypto
+
+import (
+	"crypto/cipher"
+
+	boringssl "github.com/xtls/xray-core/crypto"
+)
+
+// Runtime BoringSSL availability check
+var UseBoringSSL = true
+
+func init() {
+	// Check if BoringSSL is actually available at runtime
+	// If BoringSSL init fails, fall back to Go stdlib
+	defer func() {
+		if r := recover(); r != nil {
+			UseBoringSSL = false
+		}
+	}()
+
+	// Try to initialize BoringSSL
+	// This will panic if BoringSSL is not available
+	_, _ = boringssl.RandomBytes(1)
+}
+
+// NewGCM creates a GCM cipher using BoringSSL when available
+func NewGCM(block cipher.Block) (cipher.AEAD, error) {
+	if UseBoringSSL {
+		return NewBoringSSLGCM(block)
+	}
+	return cipher.NewGCM(block)
+}
+
+// NewBoringSSLGCM creates a BoringSSL-backed GCM cipher
+func NewBoringSSLGCM(block cipher.Block) (cipher.AEAD, error) {
+	// For now, fallback to standard GCM
+	return cipher.NewGCM(block)
+}
diff --git a/common/crypto/crypto_nocgo.go b/common/crypto/crypto_nocgo.go
new file mode 100644
index 0000000..892f38b
--- /dev/null
+++ b/common/crypto/crypto_nocgo.go
@@ -0,0 +1,16 @@
+//go:build !cgo
+// +build !cgo
+
+package crypto
+
+import (
+	"crypto/cipher"
+)
+
+// No BoringSSL support when CGO is disabled
+var UseBoringSSL = false
+
+// NewGCM creates a GCM cipher using standard library
+func NewGCM(block cipher.Block) (cipher.AEAD, error) {
+	return cipher.NewGCM(block)
+}
